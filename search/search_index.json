{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyclugen","text":"<p>pyclugen is Python package for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. The <code>clugen()</code> function is provided for this purpose, as well as a number of auxiliary functions, used internally and modularly by <code>clugen()</code>. Users can swap these auxiliary functions by their own customized versions, fine-tuning their cluster generation strategies, or even use them as the basis for their own generation algorithms.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install --upgrade pip\npip install pyclugen\n</code></pre> <p>Or directly from GitHub:</p> <pre><code>pip install --upgrade pip\npip install git+https://github.com/clugen/pyclugen.git#egg=pyclugen\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from pyclugen import clugen\nimport matplotlib.pyplot as plt\n</code></pre> <pre><code>out2 = clugen(2, 4, 400, [1, 0], 0.4, [50, 10], 20, 1, 2)\nplt.scatter(out2.points[:, 0], out2.points[:, 1], c=out2.clusters)\nplt.show()\n</code></pre> <pre><code>out3 = clugen(3, 5, 10000, [0.5, 0.5, 0.5], 0.2, [10, 10, 10], 10, 1, 2)\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\nax.scatter(out3.points[:, 0], out3.points[:, 1], out3.points[:, 2], c=out3.clusters)\nplt.show()\n</code></pre>"},{"location":"#further-reading","title":"Further reading","text":"<p>The clugen algorithm and its several implementations are detailed in the following reference (please cite it if you use this software):</p> <ul> <li>Fachada, N. &amp; de Andrade, D. (2023). Generating Multidimensional Clusters With   Support Lines. https://doi.org/10.48550/arXiv.2301.10327.</li> </ul>"},{"location":"#also-in-this-documentation","title":"Also in this documentation","text":"<ul> <li>Theory: the clugen algorithm in detail</li> <li>Detailed usage examples</li> <li>Reference</li> <li>Developing this package</li> </ul>"},{"location":"dev/","title":"Development","text":""},{"location":"dev/#installing-for-development-andor-improving-the-package","title":"Installing for development and/or improving the package","text":"<pre><code>$ git clone https://github.com/clugen/pyclugen.git\n$ cd pyclugen\n$ python -m venv env\n$ source env/bin/activate\n$ pip install -e .[dev]\n$ pre-commit install\n</code></pre> <p>On Windows replace <code>source env/bin/activate</code> with <code>. env\\Scripts\\activate</code>.</p>"},{"location":"dev/#run-tests","title":"Run tests","text":"<p>Tests can be executed with the following command:</p> <pre><code>$ pytest\n</code></pre> <p>The previous command runs the tests at <code>normal</code> level by default. This test level can also be specified explicitly:</p> <pre><code>$ pytest --test-level=normal\n</code></pre> <p>There are four test levels, from fastest to slowest (i.e., from less thorough to more exhaustive): <code>fast</code>, <code>ci</code>, <code>normal</code> and <code>full</code>. The <code>fast</code> level tests all functions using typical parameters, just to check if everything is working. The <code>ci</code> level performs the minimal amount of testing that yields complete test coverage. Beyond complete coverage, the <code>normal</code> and <code>full</code> levels also test increasing combinations of parameters and PRNG seeds, which may be important to root out rare corner cases. Note that the <code>full</code> level can be extremely slow.</p> <p>To generate a test coverage report, run pytest as follows:</p> <pre><code>$ pytest --cov=pyclugen --cov-report=html --test-level=ci\n</code></pre>"},{"location":"dev/#build-docs","title":"Build docs","text":"<p>Considering we're in the <code>pyclugen</code> folder, run the following commands:</p> <pre><code>$ cd docs\n$ mkdocs build\n</code></pre> <p>The generated documentation will be placed in <code>docs/site</code>. Alternatively, the documentation can be generated and served locally with:</p> <pre><code>$ mkdocs serve\n</code></pre>"},{"location":"dev/#code-style","title":"Code style","text":"<p>Code style is enforced with flake8 (and a number of plugins), black, and isort. Some highlights include, but are not limited to:</p> <ul> <li>Encoding: UTF-8</li> <li>Indentation: 4 spaces (no tabs)</li> <li>Line size limit: 88 chars</li> <li>Newlines: Unix style, i.e. LF or \\n</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Various functions for multidimensional cluster generation in Python.</p> <p>Note that:</p> <ol> <li><code>clugen()</code> is the main function of the pyclugen    package, and possibly the only function most users will need.</li> <li>Functions which accept <code>rng</code> as the last parameter are stochastic. Thus, in    order to obtain the same result on separate invocations of these functions,    pass them an an instance of same pseudo-random number    <code>Generator</code> initialized with the same seed.</li> </ol>"},{"location":"reference/#pyclugen.Clusters","title":"Clusters","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Read-only container for results returned by <code>clugen()</code>.</p> <p>The symbols presented in the instances variable below have the following meanings:</p> <ul> <li>\\(n\\) : Number of dimensions.</li> <li>\\(p\\) : Number of points.</li> <li>\\(c\\) : Number of clusters.</li> </ul> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/main.py</code> <pre><code>class Clusters(NamedTuple):\nr\"\"\"Read-only container for results returned by [`clugen()`][pyclugen.main.clugen].\n    The symbols presented in the instances variable below have the following\n    meanings:\n    - $n$ : Number of dimensions.\n    - $p$ : Number of points.\n    - $c$ : Number of clusters.\n    \"\"\"\npoints: NDArray\nr\"\"\"$p \\times n$ matrix containing the generated points for all clusters.\"\"\"\nclusters: NDArray\nr\"\"\"Vector of size $p$ indicating the cluster each point in `points`\n    belongs to.\"\"\"\nprojections: NDArray\nr\"\"\"$p \\times n$ matrix with the point projections on the cluster-supporting\n    lines.\"\"\"\nsizes: NDArray\nr\"\"\"Vector of size $c$ with the number of points in each cluster.\"\"\"\ncenters: NDArray\nr\"\"\"$c \\times n$ matrix with the coordinates of the cluster centers.\"\"\"\ndirections: NDArray\nr\"\"\"$c \\times n$ matrix with the direction of each cluster-supporting line.\"\"\"\nangles: NDArray\nr\"\"\"Vector of size $c$ with the angles between the cluster-supporting lines and\n    the main direction.\"\"\"\nlengths: NDArray\nr\"\"\"Vector of size $c$ with the lengths of the cluster-supporting lines.\"\"\"\n</code></pre>"},{"location":"reference/#pyclugen.main.Clusters.angles","title":"angles  <code>instance-attribute</code>","text":"<pre><code>angles: NDArray\n</code></pre> <p>Vector of size \\(c\\) with the angles between the cluster-supporting lines and the main direction.</p>"},{"location":"reference/#pyclugen.main.Clusters.centers","title":"centers  <code>instance-attribute</code>","text":"<pre><code>centers: NDArray\n</code></pre> <p>\\(c \\times n\\) matrix with the coordinates of the cluster centers.</p>"},{"location":"reference/#pyclugen.main.Clusters.clusters","title":"clusters  <code>instance-attribute</code>","text":"<pre><code>clusters: NDArray\n</code></pre> <p>Vector of size \\(p\\) indicating the cluster each point in <code>points</code> belongs to.</p>"},{"location":"reference/#pyclugen.main.Clusters.directions","title":"directions  <code>instance-attribute</code>","text":"<pre><code>directions: NDArray\n</code></pre> <p>\\(c \\times n\\) matrix with the direction of each cluster-supporting line.</p>"},{"location":"reference/#pyclugen.main.Clusters.lengths","title":"lengths  <code>instance-attribute</code>","text":"<pre><code>lengths: NDArray\n</code></pre> <p>Vector of size \\(c\\) with the lengths of the cluster-supporting lines.</p>"},{"location":"reference/#pyclugen.main.Clusters.points","title":"points  <code>instance-attribute</code>","text":"<pre><code>points: NDArray\n</code></pre> <p>\\(p \\times n\\) matrix containing the generated points for all clusters.</p>"},{"location":"reference/#pyclugen.main.Clusters.projections","title":"projections  <code>instance-attribute</code>","text":"<pre><code>projections: NDArray\n</code></pre> <p>\\(p \\times n\\) matrix with the point projections on the cluster-supporting lines.</p>"},{"location":"reference/#pyclugen.main.Clusters.sizes","title":"sizes  <code>instance-attribute</code>","text":"<pre><code>sizes: NDArray\n</code></pre> <p>Vector of size \\(c\\) with the number of points in each cluster.</p>"},{"location":"reference/#pyclugen.angle_btw","title":"angle_btw","text":"<pre><code>angle_btw(v1: NDArray, v2: NDArray) -&gt; float\n</code></pre> <p>Angle between two \\(n\\)-dimensional vectors.</p> <p>Typically, the angle between two vectors <code>v1</code> and <code>v2</code> can be obtained with:</p> <pre><code>arccos(dot(u, v) / (norm(u) * norm(v)))\n</code></pre> <p>However, this approach is numerically unstable. The version provided here is numerically stable and based on the AngleBetweenVectors Julia package by Jeffrey Sarnoff (MIT license), implementing an algorithm provided by Prof. W. Kahan in these notes (see page 15).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy import array, degrees\n&gt;&gt;&gt; from pyclugen import angle_btw\n&gt;&gt;&gt; v1 = array([1.0, 1.0, 1.0, 1.0])\n&gt;&gt;&gt; v2 = array([1.0, 0.0, 0.0, 0.0])\n&gt;&gt;&gt; degrees(angle_btw(v1, v2))\n60.00000000000001\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>NDArray</code> <p>First vector.</p> required <code>v2</code> <code>NDArray</code> <p>Second vector.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Angle between <code>v1</code> and <code>v2</code> in radians.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/helper.py</code> <pre><code>def angle_btw(v1: NDArray, v2: NDArray) -&gt; float:\nr\"\"\"Angle between two $n$-dimensional vectors.\n    Typically, the angle between two vectors `v1` and `v2` can be obtained with:\n    ```python\n    arccos(dot(u, v) / (norm(u) * norm(v)))\n    ```\n    However, this approach is numerically unstable. The version provided here is\n    numerically stable and based on the\n    [AngleBetweenVectors](https://github.com/JeffreySarnoff/AngleBetweenVectors.jl)\n    Julia package by Jeffrey Sarnoff (MIT license), implementing an algorithm\n    provided by Prof. W. Kahan in\n    [these notes](https://people.eecs.berkeley.edu/~wkahan/MathH110/Cross.pdf)\n    (see page 15).\n    Examples:\n        &gt;&gt;&gt; from numpy import array, degrees\n        &gt;&gt;&gt; from pyclugen import angle_btw\n        &gt;&gt;&gt; v1 = array([1.0, 1.0, 1.0, 1.0])\n        &gt;&gt;&gt; v2 = array([1.0, 0.0, 0.0, 0.0])\n        &gt;&gt;&gt; degrees(angle_btw(v1, v2))\n        60.00000000000001\n    Args:\n      v1: First vector.\n      v2: Second vector.\n    Returns:\n      Angle between `v1` and `v2` in radians.\n    \"\"\"\nu1 = v1 / norm(v1)\nu2 = v2 / norm(v2)\ny = u1 - u2\nx = u1 + u2\nreturn 2 * arctan(norm(y) / norm(x))\n</code></pre>"},{"location":"reference/#pyclugen.angle_deltas","title":"angle_deltas","text":"<pre><code>angle_deltas(\nnum_clusters: int, angle_disp: float, rng: Generator = _default_rng\n) -&gt; NDArray\n</code></pre> <p>Get angles between average cluster direction and cluster-supporting lines.</p> <p>Determine the angles between the average cluster direction and the cluster-supporting lines. These angles are obtained from a wrapped normal distribution ( \\(\\mu=0\\), \\(\\sigma=\\)<code>angle_disp</code>) with support in the interval \\(\\left[-\\pi/2,\\pi/2\\right]\\). Note this is different from the standard wrapped normal distribution, the support of which is given by the interval \\(\\left[-\\pi,\\pi\\right]\\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import angle_deltas\n&gt;&gt;&gt; from numpy import degrees, pi\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; prng = Generator(PCG64(123))\n&gt;&gt;&gt; a_rad = angle_deltas(4, pi/8, rng=prng) # Angle dispersion of 22.5 degrees\n&gt;&gt;&gt; a_rad\narray([-0.38842705, -0.14442948,  0.50576707,  0.07617358])\n&gt;&gt;&gt; degrees(a_rad) # Show angle deltas in degrees\narray([-22.25523038,  -8.27519966,  28.97831838,   4.36442443])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_clusters</code> <code>int</code> <p>Number of clusters.</p> required <code>angle_disp</code> <code>float</code> <p>Angle dispersion, in radians.</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Angles between the average cluster direction and the cluster-supporting lines, given in radians in the interval \\(\\left[-\\pi/2,\\pi/2\\right]\\).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def angle_deltas(\nnum_clusters: int, angle_disp: float, rng: Generator = _default_rng\n) -&gt; NDArray:\nr\"\"\"Get angles between average cluster direction and cluster-supporting lines.\n    Determine the angles between the average cluster direction and the\n    cluster-supporting lines. These angles are obtained from a wrapped normal\n    distribution ( $\\mu=0$, $\\sigma=$`angle_disp`) with support in the interval\n    $\\left[-\\pi/2,\\pi/2\\right]$. Note this is different from the standard\n    wrapped normal distribution, the support of which is given by the interval\n    $\\left[-\\pi,\\pi\\right]$.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import angle_deltas\n        &gt;&gt;&gt; from numpy import degrees, pi\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; prng = Generator(PCG64(123))\n        &gt;&gt;&gt; a_rad = angle_deltas(4, pi/8, rng=prng) # Angle dispersion of 22.5 degrees\n        &gt;&gt;&gt; a_rad\n        array([-0.38842705, -0.14442948,  0.50576707,  0.07617358])\n        &gt;&gt;&gt; degrees(a_rad) # Show angle deltas in degrees\n        array([-22.25523038,  -8.27519966,  28.97831838,   4.36442443])\n    Args:\n      num_clusters: Number of clusters.\n      angle_disp: Angle dispersion, in radians.\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Angles between the average cluster direction and the cluster-supporting\n        lines, given in radians in the interval $\\left[-\\pi/2,\\pi/2\\right]$.\n    \"\"\"\n# Get random angle differences using the normal distribution\nangles = angle_disp * rng.normal(size=num_clusters)\n# Reduce angle differences to the interval [-\u03c0, \u03c0]\nangles = arctan2(sin(angles), cos(angles))\n# Make sure angle differences are within interval [-\u03c0/2, \u03c0/2]\nreturn where(abs(angles) &gt; pi / 2, angles - sign(angles) * pi / 2, angles)\n</code></pre>"},{"location":"reference/#pyclugen.clucenters","title":"clucenters","text":"<pre><code>clucenters(\nnum_clusters: int,\nclu_sep: NDArray,\nclu_offset: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Determine cluster centers using the uniform distribution.</p> <p>The number of clusters (<code>num_clusters</code>) and the average cluster separation (<code>clu_sep</code>) are taken into account.</p> <p>More specifically, let \\(c=\\)<code>num_clusters</code>, \\(\\mathbf{s}=\\)<code>clu_sep.reshape(-1,1)</code>, \\(\\mathbf{o}=\\)<code>clu_offset.reshape(-1,1)</code>, \\(n=\\)<code>clu_sep.size</code> (i.e., number of dimensions). Cluster centers are obtained according to the following equation:</p> \\[ \\mathbf{C}=c\\mathbf{U} \\cdot \\operatorname{diag}(\\mathbf{s}) +     \\mathbf{1}\\,\\mathbf{o}^T \\] <p>where \\(\\mathbf{C}\\) is the \\(c \\times n\\) matrix of cluster centers, \\(\\mathbf{U}\\) is an \\(c \\times n\\) matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and \\(\\mathbf{1}\\) is an \\(c \\times 1\\) vector with all entries equal to 1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import clucenters\n&gt;&gt;&gt; from numpy import array\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; prng = Generator(PCG64(123))\n&gt;&gt;&gt; clucenters(3, array([30,10]), array([-50,50]), rng=prng)\narray([[-33.58833231,  36.61463056],\n       [-75.16761145,  40.53115432],\n       [-79.1684689 ,  59.3628352 ]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_clusters</code> <code>int</code> <p>Number of clusters.</p> required <code>clu_sep</code> <code>NDArray</code> <p>Average cluster separation ( \\(n \\times 1\\) vector).</p> required <code>clu_offset</code> <code>NDArray</code> <p>Cluster offsets ( \\(n \\times 1\\) vector).</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A \\(c \\times n\\) matrix containing the cluster centers.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def clucenters(\nnum_clusters: int,\nclu_sep: NDArray,\nclu_offset: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Determine cluster centers using the uniform distribution.\n    The number of clusters (`num_clusters`) and the average cluster separation\n    (`clu_sep`) are taken into account.\n    More specifically, let $c=$`num_clusters`, $\\mathbf{s}=$`clu_sep.reshape(-1,1)`,\n    $\\mathbf{o}=$`clu_offset.reshape(-1,1)`, $n=$`clu_sep.size` (i.e., number of\n    dimensions). Cluster centers are obtained according to the following equation:\n    $$\n    \\mathbf{C}=c\\mathbf{U} \\cdot \\operatorname{diag}(\\mathbf{s}) +\n        \\mathbf{1}\\,\\mathbf{o}^T\n    $$\n    where $\\mathbf{C}$ is the $c \\times n$ matrix of cluster centers,\n    $\\mathbf{U}$ is an $c \\times n$ matrix of random values drawn from the\n    uniform distribution between -0.5 and 0.5, and $\\mathbf{1}$ is an $c \\times\n    1$ vector with all entries equal to 1.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import clucenters\n        &gt;&gt;&gt; from numpy import array\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; prng = Generator(PCG64(123))\n        &gt;&gt;&gt; clucenters(3, array([30,10]), array([-50,50]), rng=prng)\n        array([[-33.58833231,  36.61463056],\n               [-75.16761145,  40.53115432],\n               [-79.1684689 ,  59.3628352 ]])\n    Args:\n      num_clusters: Number of clusters.\n      clu_sep: Average cluster separation ( $n \\times 1$ vector).\n      clu_offset: Cluster offsets ( $n \\times 1$ vector).\n      rng: Optional pseudo-random number generator.\n    Returns:\n        A $c \\times n$ matrix containing the cluster centers.\n    \"\"\"\n# Obtain a num_clusters x num_dims matrix of uniformly distributed values\n# between -0.5 and 0.5 representing the relative cluster centers\nctr_rel = rng.random((num_clusters, clu_sep.size)) - 0.5\nreturn num_clusters * (ctr_rel @ diag(clu_sep)) + clu_offset\n</code></pre>"},{"location":"reference/#pyclugen.clugen","title":"clugen","text":"<pre><code>clugen(\nnum_dims: int,\nnum_clusters: int,\nnum_points: int,\ndirection: ArrayLike,\nangle_disp: float,\ncluster_sep: ArrayLike,\nllength: float,\nllength_disp: float,\nlateral_disp: float,\nallow_empty: bool = False,\ncluster_offset: Optional[ArrayLike] = None,\nproj_dist_fn: str | Callable[[float, int, Generator], NDArray] = \"norm\",\npoint_dist_fn: str\n| Callable[\n[NDArray, float, float, NDArray, NDArray, Generator], NDArray\n] = \"n-1\",\nclusizes_fn: Callable[[int, int, bool, Generator], NDArray]\n| ArrayLike = clusizes,\nclucenters_fn: Callable[[int, NDArray, NDArray, Generator], NDArray]\n| ArrayLike = clucenters,\nllengths_fn: Callable[[int, float, float, Generator], NDArray]\n| ArrayLike = llengths,\nangle_deltas_fn: Callable[[int, float, Generator], NDArray]\n| ArrayLike = angle_deltas,\nrng: Generator = _default_rng,\n) -&gt; Clusters\n</code></pre> <p>Generate multidimensional clusters.</p> <p>Tip</p> <p>This is the main function of the pyclugen package, and possibly the only function most users will need.</p>"},{"location":"reference/#pyclugen.clugen--examples","title":"Examples:","text":"<pre><code>&gt;&gt;&gt; import pyclugen as cg\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from numpy import pi\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; rng = Generator(PCG64(321))\n&gt;&gt;&gt; out = cg.clugen(2, 5, 10000, [1, 0.5], pi/16, [10, 40], 10, 1, 2, rng=rng)\n&gt;&gt;&gt; out.centers # What are the cluster centers?\narray([[ 20.02876212,  36.59611434],\n       [-15.60290734, -26.52169579],\n       [ 23.09775166,  91.66309916],\n       [ -5.76816015,  54.9775074 ],\n       [ -4.64224681,  78.40990876]])\n&gt;&gt;&gt; plt.scatter(out.points[:,0],\n...             out.points[:,1],\n...             c=out.clusters) # doctest: +SKIP\n&gt;&gt;&gt; plt.show() # doctest: +SKIP\n</code></pre> <p>Note</p> <p>In the descriptions below, the terms \"average\" and \"dispersion\" refer to measures of central tendency and statistical dispersion, respectively. Their exact meaning depends on several optional arguments.</p> <p>Parameters:</p> Name Type Description Default <code>num_dims</code> <code>int</code> <p>Number of dimensions.</p> required <code>num_clusters</code> <code>int</code> <p>Number of clusters to generate.</p> required <code>num_points</code> <code>int</code> <p>Total number of points to generate.</p> required <code>direction</code> <code>ArrayLike</code> <p>Average direction of the cluster-supporting lines. Can be a vector of length <code>num_dims</code> (same direction for all clusters) or a matrix of size <code>num_clusters</code> x <code>num_dims</code> (one direction per cluster).</p> required <code>angle_disp</code> <code>float</code> <p>Angle dispersion of cluster-supporting lines (radians).</p> required <code>cluster_sep</code> <code>ArrayLike</code> <p>Average cluster separation in each dimension (vector of size <code>num_dims</code>).</p> required <code>llength</code> <code>float</code> <p>Average length of cluster-supporting lines.</p> required <code>llength_disp</code> <code>float</code> <p>Length dispersion of cluster-supporting lines.</p> required <code>lateral_disp</code> <code>float</code> <p>Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line.</p> required <code>allow_empty</code> <code>bool</code> <p>Allow empty clusters? <code>False</code> by default.</p> <code>False</code> <code>cluster_offset</code> <code>Optional[ArrayLike]</code> <p>Offset to add to all cluster centers (vector of size <code>num_dims</code>). By default the offset will be equal to <code>numpy.zeros(num_dims)</code>.</p> <code>None</code> <code>proj_dist_fn</code> <code>str | Callable[[float, int, Generator], NDArray]</code> <p>Distribution of point projections along cluster-supporting lines, with three possible values:</p> <ul> <li><code>\"norm\"</code> (default): Distribute point projections along lines using a normal   distribution (\u03bc=line center, \u03c3=<code>llength/6</code>).</li> <li><code>\"unif\"</code>: Distribute points uniformly along the line.</li> <li>User-defined function, which accepts two parameters, line length (<code>float</code>),   number of points (<code>int</code>) and an instance of   <code>Generator</code>,   and returns an array containing the distance of each point projection to   the center of the line. For example, the <code>\"norm\"</code> option roughly corresponds   to <code>lambda l, n, rg: l * rg.random((n, 1)) / 6</code>.</li> </ul> <code>'norm'</code> <code>point_dist_fn</code> <code>str | Callable[[NDArray, float, float, NDArray, NDArray, Generator], NDArray]</code> <p>Controls how the final points are created from their projections on the cluster-supporting lines, with three possible values:</p> <ul> <li><code>\"n-1\"</code> (default): Final points are placed on a hyperplane orthogonal to   the cluster-supporting line, centered at each point's projection, using the   normal distribution (\u03bc=0, \u03c3=<code>lateral_disp</code>). This is done by the   <code>clupoints_n_1()</code> function.</li> <li><code>\"n\"</code>: Final points are placed around their projection on the   cluster-supporting line using the normal distribution (\u03bc=0,   \u03c3=<code>lateral_disp</code>). This is done by the   <code>clupoints_n()</code> function.</li> <li>User-defined function: The user can specify a custom point placement   strategy by passing a function with the same signature as   <code>clupoints_n_1()</code> and   <code>clupoints_n()</code>.</li> </ul> <code>'n-1'</code> <code>clusizes_fn</code> <code>Callable[[int, int, bool, Generator], NDArray] | ArrayLike</code> <p>Distribution of cluster sizes. By default, cluster sizes are determined by the <code>clusizes()</code> function, which uses the normal distribution (\u03bc=<code>num_points</code>/<code>num_clusters</code>, \u03c3=\u03bc/3), and assures that the final cluster sizes add up to <code>num_points</code>. This parameter allows the user to specify a custom function for this purpose, which must follow <code>clusizes()</code> signature. Note that custom functions are not required to strictly obey the <code>num_points</code> parameter. Alternatively, the user can specify an array of cluster sizes directly.</p> <code>clusizes</code> <code>clucenters_fn</code> <code>Callable[[int, NDArray, NDArray, Generator], NDArray] | ArrayLike</code> <p>Distribution of cluster centers. By default, cluster centers are determined by the <code>clucenters()</code> function, which uses the uniform distribution, and takes into account the <code>num_clusters</code> and <code>cluster_sep</code> parameters for generating well-distributed cluster centers. This parameter allows the user to specify a custom function for this purpose, which must follow <code>clucenters()</code> signature. Alternatively, the user can specify a matrix of size <code>num_clusters</code> x <code>num_dims</code> with the exact cluster centers.</p> <code>clucenters</code> <code>llengths_fn</code> <code>Callable[[int, float, float, Generator], NDArray] | ArrayLike</code> <p>Distribution of line lengths. By default, the lengths of cluster-supporting lines are determined by the <code>llengths()</code> function, which uses the folded normal distribution (\u03bc=<code>llength</code>, \u03c3=<code>llength_disp</code>). This parameter allows the user to specify a custom function for this purpose, which must follow <code>llengths()</code> signature. Alternatively, the user can specify an array of line lengths directly.</p> <code>llengths</code> <code>angle_deltas_fn</code> <code>Callable[[int, float, Generator], NDArray] | ArrayLike</code> <p>Distribution of line angle differences with respect to <code>direction</code>. By default, the angles between <code>direction</code> and the direction of cluster-supporting lines are determined by the <code>angle_deltas()</code> function, which uses the wrapped normal distribution (\u03bc=0, \u03c3=<code>angle_disp</code>) with support in the interval [-\u03c0/2, \u03c0/2]. This parameter allows the user to specify a custom function for this purpose, which must follow <code>angle_deltas()</code> signature. Alternatively, the user can specify an array of angle deltas directly.</p> <code>angle_deltas</code> <code>rng</code> <code>Generator</code> <p>An optional instance of <code>Generator</code> for reproducible executions.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>Clusters</code> <p>The generated clusters and associated information in the form of a <code>Clusters</code> object.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/main.py</code> <pre><code>def clugen(\nnum_dims: int,\nnum_clusters: int,\nnum_points: int,\ndirection: ArrayLike,\nangle_disp: float,\ncluster_sep: ArrayLike,\nllength: float,\nllength_disp: float,\nlateral_disp: float,\nallow_empty: bool = False,\ncluster_offset: Optional[ArrayLike] = None,\nproj_dist_fn: str | Callable[[float, int, Generator], NDArray] = \"norm\",\npoint_dist_fn: str\n| Callable[[NDArray, float, float, NDArray, NDArray, Generator], NDArray] = \"n-1\",\nclusizes_fn: Callable[[int, int, bool, Generator], NDArray] | ArrayLike = clusizes,\nclucenters_fn: Callable[[int, NDArray, NDArray, Generator], NDArray]\n| ArrayLike = clucenters,\nllengths_fn: Callable[[int, float, float, Generator], NDArray]\n| ArrayLike = llengths,\nangle_deltas_fn: Callable[[int, float, Generator], NDArray]\n| ArrayLike = angle_deltas,\nrng: Generator = _default_rng,\n) -&gt; Clusters:\n\"\"\"Generate multidimensional clusters.\n    !!! tip\n        This is the main function of the **pyclugen** package, and possibly the\n        only function most users will need.\n    ## Examples:\n        &gt;&gt;&gt; import pyclugen as cg\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; from numpy import pi\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; rng = Generator(PCG64(321))\n        &gt;&gt;&gt; out = cg.clugen(2, 5, 10000, [1, 0.5], pi/16, [10, 40], 10, 1, 2, rng=rng)\n        &gt;&gt;&gt; out.centers # What are the cluster centers?\n        array([[ 20.02876212,  36.59611434],\n               [-15.60290734, -26.52169579],\n               [ 23.09775166,  91.66309916],\n               [ -5.76816015,  54.9775074 ],\n               [ -4.64224681,  78.40990876]])\n        &gt;&gt;&gt; plt.scatter(out.points[:,0],\n        ...             out.points[:,1],\n        ...             c=out.clusters) # doctest: +SKIP\n        &gt;&gt;&gt; plt.show() # doctest: +SKIP\n    ![clugen](https://user-images.githubusercontent.com/3018963/151056890-c83c9509-b40d-4ab2-a842-f2a4706344c6.png)\n    !!! Note\n        In the descriptions below, the terms \"average\" and \"dispersion\" refer to\n        measures of central tendency and statistical dispersion, respectively.\n        Their exact meaning depends on several optional arguments.\n    Args:\n      num_dims: Number of dimensions.\n      num_clusters: Number of clusters to generate.\n      num_points: Total number of points to generate.\n      direction: Average direction of the cluster-supporting lines. Can be a\n        vector of length `num_dims` (same direction for all clusters) or a\n        matrix of size `num_clusters` x `num_dims` (one direction per cluster).\n      angle_disp: Angle dispersion of cluster-supporting lines (radians).\n      cluster_sep: Average cluster separation in each dimension (vector of size\n        `num_dims`).\n      llength: Average length of cluster-supporting lines.\n      llength_disp: Length dispersion of cluster-supporting lines.\n      lateral_disp: Cluster lateral dispersion, i.e., dispersion of points from their\n        projection on the cluster-supporting line.\n      allow_empty: Allow empty clusters? `False` by default.\n      cluster_offset: Offset to add to all cluster centers (vector of size `num_dims`).\n        By default the offset will be equal to `numpy.zeros(num_dims)`.\n      proj_dist_fn: Distribution of point projections along cluster-supporting lines,\n        with three possible values:\n        - `\"norm\"` (default): Distribute point projections along lines using a normal\n          distribution (\u03bc=_line center_, \u03c3=`llength/6`).\n        - `\"unif\"`: Distribute points uniformly along the line.\n        - User-defined function, which accepts two parameters, line length (`float`),\n          number of points (`int`) and an instance of\n          [`Generator`](https://numpy.org/doc/stable/reference/random/generator.html?highlight=generator#numpy.random.Generator),\n          and returns an array containing the distance of each point projection to\n          the center of the line. For example, the `\"norm\"` option roughly corresponds\n          to `lambda l, n, rg: l * rg.random((n, 1)) / 6`.\n      point_dist_fn: Controls how the final points are created from their projections\n        on the cluster-supporting lines, with three possible values:\n        - `\"n-1\"` (default): Final points are placed on a hyperplane orthogonal to\n          the cluster-supporting line, centered at each point's projection, using the\n          normal distribution (\u03bc=0, \u03c3=`lateral_disp`). This is done by the\n          [`clupoints_n_1()`][pyclugen.module.clupoints_n_1] function.\n        - `\"n\"`: Final points are placed around their projection on the\n          cluster-supporting line using the normal distribution (\u03bc=0,\n          \u03c3=`lateral_disp`). This is done by the\n          [`clupoints_n()`][pyclugen.module.clupoints_n] function.\n        - User-defined function: The user can specify a custom point placement\n          strategy by passing a function with the same signature as\n          [`clupoints_n_1()`][pyclugen.module.clupoints_n_1] and\n          [`clupoints_n()`][pyclugen.module.clupoints_n].\n      clusizes_fn: Distribution of cluster sizes. By default, cluster sizes are\n        determined by the [`clusizes()`][pyclugen.module.clusizes] function, which\n        uses the normal distribution (\u03bc=`num_points`/`num_clusters`, \u03c3=\u03bc/3), and\n        assures that the final cluster sizes add up to `num_points`. This parameter\n        allows the user to specify a custom function for this purpose, which must\n        follow [`clusizes()`][pyclugen.module.clusizes] signature. Note that custom\n        functions are not required to strictly obey the `num_points` parameter.\n        Alternatively, the user can specify an array of cluster sizes directly.\n      clucenters_fn: Distribution of cluster centers. By default, cluster centers\n        are determined by the [`clucenters()`][pyclugen.module.clucenters] function,\n        which uses the uniform distribution, and takes into account the `num_clusters`\n        and `cluster_sep` parameters for generating well-distributed cluster centers.\n        This parameter allows the user to specify a custom function for this purpose,\n        which must follow [`clucenters()`][pyclugen.module.clucenters] signature.\n        Alternatively, the user can specify a matrix of size `num_clusters` x\n        `num_dims` with the exact cluster centers.\n      llengths_fn: Distribution of line lengths. By default, the lengths of\n        cluster-supporting lines are determined by the\n        [`llengths()`][pyclugen.module.llengths] function, which uses the folded\n        normal distribution (\u03bc=`llength`, \u03c3=`llength_disp`). This parameter allows\n        the user to specify a custom function for this purpose, which must follow\n        [`llengths()`][pyclugen.module.llengths] signature. Alternatively, the user\n        can specify an array of line lengths directly.\n      angle_deltas_fn: Distribution of line angle differences with respect to\n        `direction`. By default, the angles between `direction` and the direction of\n        cluster-supporting lines are determined by the\n        [`angle_deltas()`][pyclugen.module.angle_deltas] function, which uses the\n        wrapped normal distribution (\u03bc=0, \u03c3=`angle_disp`) with support in the interval\n        [-\u03c0/2, \u03c0/2]. This parameter allows the user to specify a custom function for\n        this purpose, which must follow [`angle_deltas()`][pyclugen.module.angle_deltas]\n        signature. Alternatively, the user can specify an array of angle deltas\n        directly.\n      rng: An optional instance of [`Generator`][numpy.random.Generator] for\n        reproducible executions.\n    Returns:\n      The generated clusters and associated information in the form of a\n        [`Clusters`][pyclugen.main.Clusters] object.\n    \"\"\"\n# ############### #\n# Validate inputs #\n# ############### #\n# Check that number of dimensions is &gt; 0\nif num_dims &lt; 1:\nraise ValueError(\"Number of dimensions, `num_dims`, must be &gt; 0\")\n# Check that number of clusters is &gt; 0\nif num_clusters &lt; 1:\nraise ValueError(\"Number of clusters, `num_clust`, must be &gt; 0\")\n# Convert given direction into a NumPy array\narrdir: NDArray = asarray(direction)\n# Get number of dimensions in `direction` array\ndir_ndims = arrdir.ndim\n# Is direction a vector or a matrix?\nif dir_ndims == 1:\n# It's a vector, let's convert it into a row matrix, since this will be\n# useful down the road\narrdir = arrdir.reshape((1, -1))\nelif dir_ndims == 2:\n# If a matrix was given (i.e. a main direction is given for each cluster),\n# check if the number of directions is the same as the number of clusters\ndir_size_1 = arrdir.shape[0]\nif dir_size_1 != num_clusters:\nraise ValueError(\n\"Number of rows in `direction` must be the same as the \"\n+ f\"number of clusters ({dir_size_1} != {num_clusters})\"\n)\nelse:\n# The `directions` array must be a vector or a matrix, so if we get here\n# it means we have invalid arguments\nraise ValueError(\n\"`direction` must be a vector (1D array) or a matrix (2D array), \"\n+ f\"but is {dir_ndims}D\"\n)\n# Check that direction has num_dims dimensions\ndir_size_2 = arrdir.shape[1]\nif dir_size_2 != num_dims:\nraise ValueError(\n\"Length of directions in `direction` must be equal to \"\n+ f\"`num_dims` ({dir_size_2} != {num_dims})\"\n)\n# Check that directions have magnitude &gt; 0\ndir_magnitudes = apply_along_axis(norm, 1, arrdir)\nif any(isclose(dir_magnitudes, 0)):\nraise ValueError(\"Directions in `direction` must have magnitude &gt; 0\")\n# If allow_empty is false, make sure there are enough points to distribute\n# by the clusters\nif (not allow_empty) and num_points &lt; num_clusters:\nraise ValueError(\nf\"A total of {num_points} points is not enough for \"\n+ f\"{num_clusters} non-empty clusters\"\n)\n# Check that cluster_sep has num_dims dimensions\ncluster_sep = asarray(cluster_sep)\nif cluster_sep.size != num_dims:\nraise ValueError(\n\"Length of `cluster_sep` must be equal to `num_dims` \"\n+ f\"({cluster_sep.size} != {num_dims})\"\n)\n# If given, cluster_offset must have the correct number of dimensions,\n# if not given then it will be a num_dims x 1 vector of zeros\nif cluster_offset is None:\ncluster_offset = zeros(num_dims)\nelse:\ncluster_offset = asarray(cluster_offset)\nif cluster_offset.size != num_dims:\nraise ValueError(\n\"Length of `cluster_offset` must be equal to `num_dims` \"\n+ f\"({cluster_offset.size} != {num_dims})\"\n)\n# Check that proj_dist_fn specifies a valid way for projecting points along\n# cluster-supporting lines i.e., either \"norm\" (default), \"unif\" or a\n# user-defined function\npointproj_fn: Callable[[float, int, Generator], NDArray]\nif callable(proj_dist_fn):\n# Use user-defined distribution; assume function accepts length of line\n# and number of points, and returns a number of points x 1 vector\npointproj_fn = proj_dist_fn\nelif proj_dist_fn == \"unif\":\n# Point projections will be uniformly placed along cluster-supporting lines\ndef pointproj_fn(length, n, rg):\nreturn length * rg.random(n) - length / 2\nelif proj_dist_fn == \"norm\":\n# Use normal distribution for placing point projections along cluster-supporting\n# lines, mean equal to line center, standard deviation equal to 1/6 of line\n# length such that the line length contains \u224899.73% of the points\ndef pointproj_fn(length, n, rg):\nreturn (1.0 / 6.0) * length * rg.normal(size=n)\nelse:\nraise ValueError(\n\"`proj_dist_fn` has to be either 'norm', 'unif' or user-defined function\"\n)\n# Check that point_dist_fn specifies a valid way for generating points given\n# their projections along cluster-supporting lines, i.e., either \"n-1\"\n# (default), \"n\" or a user-defined function\npt_from_proj_fn: Callable[\n[NDArray, float, float, NDArray, NDArray, Generator], NDArray\n]\nif num_dims == 1:\n# If 1D was specified, point projections are the points themselves\ndef pt_from_proj_fn(projs, lat_disp, length, clu_dir, clu_ctr, rng=rng):\nreturn projs\nelif callable(point_dist_fn):\n# Use user-defined distribution; assume function accepts point projections\n# on the line, lateral disp., cluster direction and cluster center, and\n# returns a num_points x num_dims matrix containing the final points\n# for the current cluster\npt_from_proj_fn = point_dist_fn\nelif point_dist_fn == \"n-1\":\n# Points will be placed on a hyperplane orthogonal to the cluster-supporting\n# line using a normal distribution centered at their intersection\npt_from_proj_fn = clupoints_n_1\nelif point_dist_fn == \"n\":\n# Points will be placed using a multivariate normal distribution\n# centered at the point projection\npt_from_proj_fn = clupoints_n\nelse:\nraise ValueError(\n\"point_dist_fn has to be either 'n-1', 'n' or a user-defined function\"\n)\n# ############################ #\n# Determine cluster properties #\n# ############################ #\n# Normalize main direction(s)\narrdir = apply_along_axis(lambda a: a / norm(a), 1, arrdir)\n# If only one main direction was given, expand it for all clusters\nif dir_ndims == 1:\narrdir = repeat(arrdir, num_clusters, axis=0)\n# Determine cluster sizes\nif callable(clusizes_fn):\ncluster_sizes = clusizes_fn(num_clusters, num_points, allow_empty, rng)\nelif len(asarray(clusizes_fn)) == num_clusters:\ncluster_sizes = asarray(clusizes_fn)\nelse:\nraise ValueError(\n\"clusizes_fn has to be either a function or a `num_clusters`-sized array\"\n)\n# Custom clusizes_fn's are not required to obey num_points, so we update\n# it here just in case it's different from what the user specified\nnum_points = sum(cluster_sizes)\n# Determine cluster centers\nif callable(clucenters_fn):\ncluster_centers = clucenters_fn(num_clusters, cluster_sep, cluster_offset, rng)\nelif asarray(clucenters_fn).shape == (num_clusters, num_dims):\ncluster_centers = asarray(clucenters_fn)\nelse:\nraise ValueError(\n\"clucenters_fn has to be either a function or a matrix of size \"\n+ \"`num_clusters` x `num_dims`\"\n)\n# Determine length of lines supporting clusters\nif callable(llengths_fn):\ncluster_lengths = llengths_fn(num_clusters, llength, llength_disp, rng)\nelif len(asarray(llengths_fn)) == num_clusters:\ncluster_lengths = asarray(llengths_fn)\nelse:\nraise ValueError(\n\"llengths_fn has to be either a function or a `num_clusters`-sized array\"\n)\n# Obtain angles between main direction and cluster-supporting lines\nif callable(angle_deltas_fn):\ncluster_angles = angle_deltas_fn(num_clusters, angle_disp, rng)\nelif len(asarray(angle_deltas_fn)) == num_clusters:\ncluster_angles = asarray(angle_deltas_fn)\nelse:\nraise ValueError(\n\"angle_deltas_fn has to be either a function or a \"\n+ \"`num_clusters`-sized array\"\n)\n# Determine normalized cluster directions by applying the obtained angles\ncluster_directions = apply_along_axis(\nlambda v, a: rand_vector_at_angle(v, next(a), rng),\n1,\narrdir,\niter(cluster_angles),\n)\n# ################################# #\n# Determine points for each cluster #\n# ################################# #\n# Aux. vector with cumulative sum of number of points in each cluster\ncumsum_points = concatenate((asarray([0]), cumsum(cluster_sizes)))\n# Pre-allocate data structures for holding cluster info and points\npoint_clusters: NDArray = empty(\nnum_points, dtype=int32\n)  # Cluster indices of each point\npoint_projections = empty((num_points, num_dims))  # Point projections on\n#                                                  # cluster-supporting lines\npoints = empty((num_points, num_dims))  # Final points to be generated\n# Loop through clusters and create points for each one\nfor i in range(num_clusters):\n# Start and end indexes for points in current cluster\nidx_start = cumsum_points[i]\nidx_end = cumsum_points[i + 1]\n# Update cluster indices of each point\npoint_clusters[idx_start:idx_end] = i\n# Determine distance of point projections from the center of the line\nptproj_dist_fn_center = pointproj_fn(cluster_lengths[i], cluster_sizes[i], rng)\n# Determine coordinates of point projections on the line using the\n# parametric line equation (this works since cluster direction is normalized)\npoint_projections[idx_start:idx_end, :] = points_on_line(\ncluster_centers[i, :], cluster_directions[i, :], ptproj_dist_fn_center\n)\n# Determine points from their projections on the line\npoints[idx_start:idx_end, :] = pt_from_proj_fn(\npoint_projections[idx_start:idx_end, :],\nlateral_disp,\ncluster_lengths[i],\ncluster_directions[i, :],\ncluster_centers[i, :],\nrng,\n)\nreturn Clusters(\npoints,\npoint_clusters,\npoint_projections,\ncluster_sizes,\ncluster_centers,\ncluster_directions,\ncluster_angles,\ncluster_lengths,\n)\n</code></pre>"},{"location":"reference/#pyclugen.clumerge","title":"clumerge","text":"<pre><code>clumerge(\n*data: NamedTuple | Mapping[str, ArrayLike],\nfields: tuple[str, ...] = (\"points\", \"clusters\"),\nclusters_field: str | None = \"clusters\"\n) -&gt; dict[str, NDArray]\n</code></pre> <p>Merges the fields (specified in <code>fields</code>) of two or more <code>data</code> sets.</p> <p>Merges the fields (specified in <code>fields</code>) of two or more <code>data</code> sets (named tuples or dictionaries). The fields to be merged need to have the same number of columns. The corresponding merged field will contain the rows of the fields to be merged, and will have a common supertype.</p> <p>The <code>clusters_field</code> parameter specifies a field containing integers that identify the cluster to which the respective points belongs to. If <code>clusters_field</code> is specified (by default it's specified as <code>\"clusters\"</code>), cluster assignments in individual datasets will be updated in the merged dataset so that clusters are considered separate. This parameter can be set to <code>None</code>, in which case no field will be considered as a special cluster assignments field.</p> <p>This function can be used to merge data sets generated with the <code>clugen()</code> function, by default merging the <code>points</code> and <code>clusters</code> fields in those data sets. It also works with arbitrary data by specifying alternative fields in the <code>fields</code> parameter. It can be used, for example, to merge third-party data with <code>clugen()</code>-generated data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import clugen, clumerge\n&gt;&gt;&gt; data1 = clugen(2, 5, 1000, [1, 1], 0.01, [20, 20], 14, 1.2, 1.5);\n&gt;&gt;&gt; data2 = clugen(2, 3, 450, [0.8, -0.3], 0, [25, 21], 6, 0.4, 3.5);\n&gt;&gt;&gt; data3 = clugen(2, 2, 600, [0, -0.7], 0.2, [15, 10], 1, 0.1, 5.2);\n&gt;&gt;&gt; data_merged = clumerge(data1, data2, data3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*data</code> <code>NamedTuple | Mapping[str, ArrayLike]</code> <p>One or more cluster data sets whose <code>fields</code> are to be merged.</p> <code>()</code> <code>fields</code> <code>tuple[str, ...]</code> <p>Fields to be merged, which must exist in the data set given in <code>*data</code>.</p> <code>('points', 'clusters')</code> <code>clusters_field</code> <code>str | None</code> <p>Field containing the integer cluster labels. If specified, cluster assignments in individual datasets will be updated in the merged dataset so that clusters are considered separate.</p> <code>'clusters'</code> <p>Returns:</p> Type Description <code>dict[str, NDArray]</code> <p>A dictionary, where keys correspond to field names, and values to the merged numerical arrays.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/main.py</code> <pre><code>def clumerge(\n*data: NamedTuple | Mapping[str, ArrayLike],\nfields: tuple[str, ...] = (\"points\", \"clusters\"),\nclusters_field: str | None = \"clusters\",\n) -&gt; dict[str, NDArray]:\nr\"\"\"Merges the fields (specified in `fields`) of two or more `data` sets.\n    Merges the fields (specified in `fields`) of two or more `data` sets (named\n    tuples or dictionaries). The fields to be merged need to have the same\n    number of columns. The corresponding merged field will contain the rows of\n    the fields to be merged, and will have a common supertype.\n    The `clusters_field` parameter specifies a field containing integers that\n    identify the cluster to which the respective points belongs to. If\n    `clusters_field` is specified (by default it's specified as `\"clusters\"`),\n    cluster assignments in individual datasets will be updated in the merged\n    dataset so that clusters are considered separate. This parameter can be set\n    to `None`, in which case no field will be considered as a special cluster\n    assignments field.\n    This function can be used to merge data sets generated with the\n    [`clugen()`][pyclugen.main.clugen] function, by default merging the\n    `points` and `clusters` fields in those data sets. It also works with\n    arbitrary data by specifying alternative fields in the `fields` parameter.\n    It can be used, for example, to merge third-party data with\n    [`clugen()`][pyclugen.main.clugen]-generated data.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import clugen, clumerge\n        &gt;&gt;&gt; data1 = clugen(2, 5, 1000, [1, 1], 0.01, [20, 20], 14, 1.2, 1.5);\n        &gt;&gt;&gt; data2 = clugen(2, 3, 450, [0.8, -0.3], 0, [25, 21], 6, 0.4, 3.5);\n        &gt;&gt;&gt; data3 = clugen(2, 2, 600, [0, -0.7], 0.2, [15, 10], 1, 0.1, 5.2);\n        &gt;&gt;&gt; data_merged = clumerge(data1, data2, data3)\n    Args:\n      *data: One or more cluster data sets whose `fields` are to be merged.\n      fields: Fields to be merged, which must exist in the data set given in\n        `*data`.\n      clusters_field: Field containing the integer cluster labels. If specified,\n        cluster assignments in individual datasets will be updated in the merged\n        dataset so that clusters are considered separate.\n    Returns:\n      A dictionary, where keys correspond to field names, and values to the\n        merged numerical arrays.\n    \"\"\"\n# Number of elements in each array the merged dataset\nnumel: int = 0\n# Number of columns of values in each field\nfields_info: dict[str, _FieldInfo] = {}\n# Merged dataset to output, initially empty\noutput: dict[str, NDArray] = {}\n# Create a fields set\nfields_set: MutableSet[str] = set(fields)\n# If a clusters field is given, add it\nif clusters_field is not None:\nfields_set.add(str(clusters_field))\n# Data in dictionary format with NDArray views on data\nddata: MutableSequence[Mapping[str, NDArray]] = []\nfor dt in data:\n# If dt is a named tuple, convert it into a dictionary\nddt: Mapping[str, ArrayLike]\nif isinstance(dt, dict):\nddt = cast(dict, dt)\nelse:\nntdt = cast(NamedTuple, dt)\nddt = ntdt._asdict()\n# Convert dictionary values to NDArrays\nddtnp: Mapping[str, NDArray] = {k: asarray(v) for k, v in ddt.items()}\n# Add converted dictionary to our sequence of dictionaries\nddata.append(ddtnp)\n# Cycle through data items\nfor dt in ddata:\n# Number of elements in the current item\nnumel_i: int = -1\n# Cycle through fields for the current item\nfor field in fields_set:\nif field not in dt:\nraise ValueError(f\"Data item does not contain required field `{field}`\")\nelif field == clusters_field and not can_cast(\ndt[clusters_field].dtype, int64\n):\nraise ValueError(f\"`{clusters_field}` must contain integer types\")\n# Get the field value\nvalue: NDArray = dt[field]\n# Number of elements in field value\nnumel_tmp = len(value)\n# Check the number of elements in the field value\nif numel_i == -1:\n# First field: get number of elements in value (must be the same\n# for the remaining field values)\nnumel_i = numel_tmp\nelif numel_tmp != numel_i:\n# Fields values after the first must have the same number of\n# elements\nraise ValueError(\n\"Data item contains fields with different sizes \"\n+ f\"({numel_tmp} != {numel_i})\"\n)\n# Get/check info about the field value type\nif field not in fields_info:\n# If it's the first time this field appears, just get the info\nfields_info[field] = _FieldInfo(value.dtype, _getcols(value))\nelse:\n# If this field already appeared in previous data items, get the\n# info and check/determine its compatibility with respect to\n# previous data items\nif _getcols(value) != fields_info[field].ncol:\n# Number of columns must be the same\nraise ValueError(f\"Dimension mismatch in field `{field}`\")\n# Get the common supertype\nfields_info[field].dtype = promote_types(\nfields_info[field].dtype, value.dtype\n)\n# Update total number of elements\nnumel += numel_i\n# Initialize output dictionary fields with room for all items\nfor field in fields_info:\nif fields_info[field].ncol == 1:\noutput[field] = empty((numel,), dtype=fields_info[field].dtype)\nelse:\noutput[field] = empty(\n(numel, fields_info[field].ncol), dtype=fields_info[field].dtype\n)\n# Copy items from input data to output dictionary, field-wise\ncopied: int = 0\nlast_cluster: int = 0\n# Create merged output\nfor dt in ddata:\n# How many elements to copy for the current data item?\ntocopy: int = len(dt[fields[0]])\n# Cycle through each field and its information\nfor field in fields_info:\n# Copy elements\nif field == clusters_field:\n# If this is a clusters field, update the cluster IDs\nold_clusters = unique(dt[clusters_field])\nnew_clusters = list(\nrange(last_cluster + 1, last_cluster + len(old_clusters) + 1)\n)\nold2new = zip(old_clusters, new_clusters)\nmapping = dict(old2new)\nlast_cluster = new_clusters[-1]\noutput[field][copied : (copied + tocopy)] = [\nmapping[val] for val in dt[clusters_field]\n]\nelse:\n# Otherwise just copy the elements\nncol: int = fields_info[field].ncol\noutput[field].flat[copied * ncol : (copied + tocopy) * ncol] = dt[field]\n# Update how many were copied so far\ncopied += tocopy\n# Return result\nreturn output\n</code></pre>"},{"location":"reference/#pyclugen.clupoints_n","title":"clupoints_n","text":"<pre><code>clupoints_n(\nprojs: NDArray,\nlat_disp: float,\nline_len: float,\nclu_dir: NDArray,\nclu_ctr: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Generate points from their \\(n\\)-D projections on a cluster-supporting line.</p> <p>Each point is placed around its projection using the normal distribution ( \\(\\mu=0\\), \\(\u03c3=\\)<code>lat_disp</code>).</p> <p>This function's main intended use is by the <code>clugen()</code> function, generating the final points when the <code>point_dist_fn</code> parameter is set to <code>\"n\"</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import clupoints_n, points_on_line\n&gt;&gt;&gt; from numpy import array, linspace\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; prng = Generator(PCG64(123))\n&gt;&gt;&gt; projs = points_on_line(array([5,5]),     # Get 5 point projections\n...                        array([1,0]),     # on a 2D line\n...                        linspace(-4,4,5))\n&gt;&gt;&gt; projs\narray([[1., 5.],\n       [3., 5.],\n       [5., 5.],\n       [7., 5.],\n       [9., 5.]])\n&gt;&gt;&gt; clupoints_n(projs, 0.5, 1.0, array([1,0]), array([0,0]), rng=prng)\narray([[0.50543932, 4.81610667],\n       [3.64396263, 5.09698721],\n       [5.46011545, 5.2885519 ],\n       [6.68176818, 5.27097611],\n       [8.84170227, 4.83880544]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>projs</code> <code>NDArray</code> <p>Point projections on the cluster-supporting line ( \\(p \\times n\\) matrix).</p> required <code>lat_disp</code> <code>float</code> <p>Standard deviation for the normal distribution, i.e., cluster lateral dispersion.</p> required <code>line_len</code> <code>float</code> <p>Length of cluster-supporting line (ignored).</p> required <code>clu_dir</code> <code>NDArray</code> <p>Direction of the cluster-supporting line.</p> required <code>clu_ctr</code> <code>NDArray</code> <p>Center position of the cluster-supporting line (ignored).</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Generated points ( \\(p \\times n\\) matrix).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def clupoints_n(\nprojs: NDArray,\nlat_disp: float,\nline_len: float,\nclu_dir: NDArray,\nclu_ctr: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Generate points from their $n$-D projections on a cluster-supporting line.\n    Each point is placed around its projection using the normal distribution\n    ( $\\mu=0$, $\u03c3=$`lat_disp`).\n    This function's main intended use is by the [`clugen()`][pyclugen.main.clugen]\n    function, generating the final points when the `point_dist_fn` parameter is\n    set to `\"n\"`.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import clupoints_n, points_on_line\n        &gt;&gt;&gt; from numpy import array, linspace\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; prng = Generator(PCG64(123))\n        &gt;&gt;&gt; projs = points_on_line(array([5,5]),     # Get 5 point projections\n        ...                        array([1,0]),     # on a 2D line\n        ...                        linspace(-4,4,5))\n        &gt;&gt;&gt; projs\n        array([[1., 5.],\n               [3., 5.],\n               [5., 5.],\n               [7., 5.],\n               [9., 5.]])\n        &gt;&gt;&gt; clupoints_n(projs, 0.5, 1.0, array([1,0]), array([0,0]), rng=prng)\n        array([[0.50543932, 4.81610667],\n               [3.64396263, 5.09698721],\n               [5.46011545, 5.2885519 ],\n               [6.68176818, 5.27097611],\n               [8.84170227, 4.83880544]])\n    Args:\n      projs: Point projections on the cluster-supporting line ( $p \\times n$ matrix).\n      lat_disp: Standard deviation for the normal distribution, i.e., cluster\n        lateral dispersion.\n      line_len: Length of cluster-supporting line (ignored).\n      clu_dir: Direction of the cluster-supporting line.\n      clu_ctr: Center position of the cluster-supporting line (ignored).\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Generated points ( $p \\times n$ matrix).\n    \"\"\"\n# Number of dimensions\nnum_dims = clu_dir.size\n# Number of points in this cluster\nclu_num_points = projs.shape[0]\n# Get random displacement vectors for each point projection\ndispl = lat_disp * rng.normal(size=(clu_num_points, num_dims))\n# Add displacement vectors to each point projection\npoints = projs + displ\nreturn points\n</code></pre>"},{"location":"reference/#pyclugen.clupoints_n_1","title":"clupoints_n_1","text":"<pre><code>clupoints_n_1(\nprojs: NDArray,\nlat_disp: float,\nline_len: float,\nclu_dir: NDArray,\nclu_ctr: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Generate points from their \\(n\\)-D projections on a cluster-supporting line.</p> <p>Each point is placed on a hyperplane orthogonal to that line and centered at the point's projection, using the normal distribution ( \\(\\mu=0\\), \\(\u03c3=\\)<code>lat_disp</code>).</p> <p>This function's main intended use is by the <code>clugen()</code> function, generating the final points when the <code>point_dist_fn</code> parameter is set to <code>\"n-1\"</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import clupoints_n_1, points_on_line\n&gt;&gt;&gt; from numpy import array, linspace\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; prng = Generator(PCG64(123))\n&gt;&gt;&gt; projs = points_on_line(array([5,5]),     # Get 5 point projections\n...                        array([1,0]),     # on a 2D line\n...                        linspace(-4,4,5))\n&gt;&gt;&gt; projs\narray([[1., 5.],\n       [3., 5.],\n       [5., 5.],\n       [7., 5.],\n       [9., 5.]])\n&gt;&gt;&gt; clupoints_n_1(projs, 0.5, 1.0, array([1,0]), array([0,0]), rng=prng)\narray([[1.        , 5.49456068],\n       [3.        , 5.18389333],\n       [5.        , 5.64396263],\n       [7.        , 5.09698721],\n       [9.        , 5.46011545]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>projs</code> <code>NDArray</code> <p>Point projections on the cluster-supporting line ( \\(p \\times n\\) matrix).</p> required <code>lat_disp</code> <code>float</code> <p>Standard deviation for the normal distribution, i.e., cluster lateral dispersion.</p> required <code>line_len</code> <code>float</code> <p>Length of cluster-supporting line (ignored).</p> required <code>clu_dir</code> <code>NDArray</code> <p>Direction of the cluster-supporting line.</p> required <code>clu_ctr</code> <code>NDArray</code> <p>Center position of the cluster-supporting line (ignored).</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Generated points ( \\(p \\times n\\) matrix).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def clupoints_n_1(\nprojs: NDArray,\nlat_disp: float,\nline_len: float,\nclu_dir: NDArray,\nclu_ctr: NDArray,\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Generate points from their $n$-D projections on a cluster-supporting line.\n    Each point is placed on a hyperplane orthogonal to that line and centered at\n    the point's projection, using the normal distribution ( $\\mu=0$,\n    $\u03c3=$`lat_disp`).\n    This function's main intended use is by the [`clugen()`][pyclugen.main.clugen]\n    function, generating the final points when the `point_dist_fn` parameter is\n    set to `\"n-1\"`.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import clupoints_n_1, points_on_line\n        &gt;&gt;&gt; from numpy import array, linspace\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; prng = Generator(PCG64(123))\n        &gt;&gt;&gt; projs = points_on_line(array([5,5]),     # Get 5 point projections\n        ...                        array([1,0]),     # on a 2D line\n        ...                        linspace(-4,4,5))\n        &gt;&gt;&gt; projs\n        array([[1., 5.],\n               [3., 5.],\n               [5., 5.],\n               [7., 5.],\n               [9., 5.]])\n        &gt;&gt;&gt; clupoints_n_1(projs, 0.5, 1.0, array([1,0]), array([0,0]), rng=prng)\n        array([[1.        , 5.49456068],\n               [3.        , 5.18389333],\n               [5.        , 5.64396263],\n               [7.        , 5.09698721],\n               [9.        , 5.46011545]])\n    Args:\n      projs: Point projections on the cluster-supporting line ( $p \\times n$ matrix).\n      lat_disp: Standard deviation for the normal distribution, i.e., cluster\n        lateral dispersion.\n      line_len: Length of cluster-supporting line (ignored).\n      clu_dir: Direction of the cluster-supporting line.\n      clu_ctr: Center position of the cluster-supporting line (ignored).\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Generated points ( $p \\times n$ matrix).\n    \"\"\"\n# No blank line allowed here\n# Define function to get distances from points to their projections on the\n# line (i.e., using the normal distribution)\ndef dist_fn(clu_num_points, ldisp, rg):\nreturn ldisp * rg.normal(size=clu_num_points)\n# Use clupoints_n_1_template() to do the heavy lifting\nreturn clupoints_n_1_template(projs, lat_disp, clu_dir, dist_fn, rng=rng)\n</code></pre>"},{"location":"reference/#pyclugen.clupoints_n_1_template","title":"clupoints_n_1_template","text":"<pre><code>clupoints_n_1_template(\nprojs: NDArray,\nlat_disp: float,\nclu_dir: NDArray,\ndist_fn: Callable[[int, float, Generator], NDArray],\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Create \\(p\\) points from their \\(n\\)-D projections on a cluster-supporting line.</p> <p>Each point is placed on a hyperplane orthogonal to that line and centered at the point's projection. The function specified in <code>dist_fn</code> is used to perform the actual placement.</p> <p>This function is used internally by <code>clupoints_n_1()</code> and may be useful for constructing user-defined final point placement strategies for the <code>point_dist_fn</code> parameter of the main <code>clugen()</code> function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy import array, zeros\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; from pyclugen import clupoints_n_1_template, points_on_line\n&gt;&gt;&gt; ctr = zeros(2)\n&gt;&gt;&gt; dir = array([1, 0])\n&gt;&gt;&gt; pdist = array([-0.5, -0.2, 0.1, 0.3])\n&gt;&gt;&gt; rng = Generator(PCG64(123))\n&gt;&gt;&gt; proj = points_on_line(ctr, dir, pdist)\n&gt;&gt;&gt; clupoints_n_1_template(proj, 0, dir, lambda p, l, r: r.random(p), rng=rng)\narray([[-0.5       ,  0.68235186],\n       [-0.2       , -0.05382102],\n       [ 0.1       ,  0.22035987],\n       [ 0.3       , -0.18437181]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>projs</code> <code>NDArray</code> <p>Point projections on the cluster-supporting line ( \\(p \\times n\\) matrix).</p> required <code>lat_disp</code> <code>float</code> <p>Dispersion of points from their projection.</p> required <code>clu_dir</code> <code>NDArray</code> <p>Direction of the cluster-supporting line (unit vector).</p> required <code>dist_fn</code> <code>Callable[[int, float, Generator], NDArray]</code> <p>Function to place points on a second line, orthogonal to the first. The functions accepts as parameters the number of points in the current cluster, the <code>lateral_disp</code> parameter (the same passed to the <code>clugen()</code> function), and a random number generator, returning a vector containing the distance of each point to its projection on the cluster-supporting line.</p> required <code>rng</code> <code>Generator</code> <p>An optional pseudo-random number generator for reproducible executions.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Generated points ( \\(p \\times n\\) matrix).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/helper.py</code> <pre><code>def clupoints_n_1_template(\nprojs: NDArray,\nlat_disp: float,\nclu_dir: NDArray,\ndist_fn: Callable[[int, float, Generator], NDArray],\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Create $p$ points from their $n$-D projections on a cluster-supporting line.\n    Each point is placed on a hyperplane orthogonal to that line and centered at\n    the point's projection. The function specified in `dist_fn` is used to perform\n    the actual placement.\n    This function is used internally by\n    [`clupoints_n_1()`][pyclugen.module.clupoints_n_1] and may be useful for\n    constructing user-defined final point placement strategies for the `point_dist_fn`\n    parameter of the main [`clugen()`][pyclugen.main.clugen] function.\n    Examples:\n        &gt;&gt;&gt; from numpy import array, zeros\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; from pyclugen import clupoints_n_1_template, points_on_line\n        &gt;&gt;&gt; ctr = zeros(2)\n        &gt;&gt;&gt; dir = array([1, 0])\n        &gt;&gt;&gt; pdist = array([-0.5, -0.2, 0.1, 0.3])\n        &gt;&gt;&gt; rng = Generator(PCG64(123))\n        &gt;&gt;&gt; proj = points_on_line(ctr, dir, pdist)\n        &gt;&gt;&gt; clupoints_n_1_template(proj, 0, dir, lambda p, l, r: r.random(p), rng=rng)\n        array([[-0.5       ,  0.68235186],\n               [-0.2       , -0.05382102],\n               [ 0.1       ,  0.22035987],\n               [ 0.3       , -0.18437181]])\n    Args:\n      projs: Point projections on the cluster-supporting line ( $p \\times n$ matrix).\n      lat_disp: Dispersion of points from their projection.\n      clu_dir: Direction of the cluster-supporting line (unit vector).\n      dist_fn: Function to place points on a second line, orthogonal to the first.\n        The functions accepts as parameters the number of points in the current\n        cluster, the `lateral_disp` parameter (the same passed to the\n        [`clugen()`][pyclugen.main.clugen] function), and a random number generator,\n        returning a vector containing the distance of each point to its projection\n        on the cluster-supporting line.\n      rng: An optional pseudo-random number generator for reproducible executions.\n    Returns:\n      Generated points ( $p \\times n$ matrix).\n    \"\"\"\n# Number of dimensions\nnum_dims = clu_dir.size\n# Number of points in this cluster\nclu_num_points = projs.shape[0]\n# Get distances from points to their projections on the line\npoints_dist = dist_fn(clu_num_points, lat_disp, rng)\n# Get normalized vectors, orthogonal to the current line, for each point\north_vecs = zeros((clu_num_points, num_dims))\nfor j in range(clu_num_points):\north_vecs[j, :] = rand_ortho_vector(clu_dir, rng=rng).ravel()\n# Set vector magnitudes\north_vecs = abs(points_dist).reshape(-1, 1) * orth_vecs\n# Add perpendicular vectors to point projections on the line,\n# yielding final cluster points\npoints = projs + orth_vecs\nreturn points\n</code></pre>"},{"location":"reference/#pyclugen.clusizes","title":"clusizes","text":"<pre><code>clusizes(\nnum_clusters: int,\nnum_points: int,\nallow_empty: bool,\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Determine cluster sizes, i.e., the number of points in each cluster.</p> <p>Cluster sizes are determined using the normal distribution ( \\(\\mu=\\)<code>num_points</code> \\(/\\)<code>num_clusters</code>, \\(\\sigma=\\mu/3\\)), and then assuring that the final cluster sizes add up to <code>num_points</code> via the <code>fix_num_points()</code> function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; from pyclugen import clusizes\n&gt;&gt;&gt; prng = Generator(PCG64(123))\n&gt;&gt;&gt; sizes = clusizes(4, 1000, True, rng=prng)\n&gt;&gt;&gt; sizes\narray([166, 217, 354, 263])\n&gt;&gt;&gt; sum(sizes)\n1000\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_clusters</code> <code>int</code> <p>Number of clusters.</p> required <code>num_points</code> <code>int</code> <p>Total number of points.</p> required <code>allow_empty</code> <code>bool</code> <p>Allow empty clusters?</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Number of points in each cluster (vector of size <code>num_clusters</code>).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def clusizes(\nnum_clusters: int,\nnum_points: int,\nallow_empty: bool,\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Determine cluster sizes, i.e., the number of points in each cluster.\n    Cluster sizes are determined using the normal distribution (\n    $\\mu=$`num_points` $/$`num_clusters`, $\\sigma=\\mu/3$), and then\n    assuring that the final cluster sizes add up to `num_points` via the\n    [`fix_num_points()`][pyclugen.helper.fix_num_points] function.\n    Examples:\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; from pyclugen import clusizes\n        &gt;&gt;&gt; prng = Generator(PCG64(123))\n        &gt;&gt;&gt; sizes = clusizes(4, 1000, True, rng=prng)\n        &gt;&gt;&gt; sizes\n        array([166, 217, 354, 263])\n        &gt;&gt;&gt; sum(sizes)\n        1000\n    Args:\n      num_clusters: Number of clusters.\n      num_points: Total number of points.\n      allow_empty: Allow empty clusters?\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Number of points in each cluster (vector of size `num_clusters`).\n    \"\"\"\n# Determine number of points in each cluster using the normal distribution\n# Consider the mean an equal division of points between clusters\nmean = num_points / num_clusters\n# The standard deviation is such that the interval [0, 2 * mean] will contain\n# \u224899.7% of cluster sizes\nstd = mean / 3\n# Determine points with the normal distribution\nclu_num_points = std * rng.normal(size=num_clusters) + mean\n# Set negative values to zero\nclu_num_points = where(clu_num_points &gt; 0, clu_num_points, 0)\n# Fix imbalances, so that num_points is respected\nif sum(clu_num_points) &gt; 0:  # Be careful not to divide by zero\nclu_num_points *= num_points / sum(clu_num_points)\n# Round the real values to integers since a cluster sizes is represented by\n# an integer\nclu_num_points = rint(clu_num_points).astype(int)\n# Make sure total points is respected, which may not be the case at this time due\n# to rounding\nfix_num_points(clu_num_points, num_points)\n# If empty clusters are not allowed, make sure there aren't any\nif not allow_empty:\nfix_empty(clu_num_points)\nreturn clu_num_points\n</code></pre>"},{"location":"reference/#pyclugen.fix_empty","title":"fix_empty","text":"<pre><code>fix_empty(clu_num_points: NDArray, allow_empty: bool = False) -&gt; NDArray\n</code></pre> <p>Certifies that, given enough points, no clusters are left empty.</p> <p>This is done by removing a point from the largest cluster and adding it to an empty cluster while there are empty clusters. If the total number of points is smaller than the number of clusters (or if the <code>allow_empty</code> parameter is set to <code>true</code>), this function does nothing.</p> <p>This function is used internally by <code>clusizes()</code> and might be useful for custom cluster sizing implementations given as the <code>clusizes_fn</code> parameter of the main <code>clugen()</code> function.</p> <p>Note that the array is changed in-place.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy import array\n&gt;&gt;&gt; from pyclugen import fix_empty\n&gt;&gt;&gt; clusters = array([3, 4, 5, 0, 0])\n&gt;&gt;&gt; fix_empty(clusters)\narray([3, 3, 4, 1, 1])\n&gt;&gt;&gt; clusters # Verify that the array was changed in-place\narray([3, 3, 4, 1, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>clu_num_points</code> <code>NDArray</code> <p>Number of points in each cluster (vector of size \\(c\\)), where \\(c\\) is the number of clusters.</p> required <code>allow_empty</code> <code>bool</code> <p>Allow empty clusters?</p> <code>False</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Number of points in each cluster, after being fixed by this function (vector of size \\(c\\), which is the same reference than <code>clu_num_points</code>).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/helper.py</code> <pre><code>def fix_empty(clu_num_points: NDArray, allow_empty: bool = False) -&gt; NDArray:\nr\"\"\"Certifies that, given enough points, no clusters are left empty.\n    This is done by removing a point from the largest cluster and adding it to an\n    empty cluster while there are empty clusters. If the total number of points is\n    smaller than the number of clusters (or if the `allow_empty` parameter is set\n    to `true`), this function does nothing.\n    This function is used internally by [`clusizes()`][pyclugen.module.clusizes]\n    and might be useful for custom cluster sizing implementations given as the\n    `clusizes_fn` parameter of the main [`clugen()`][pyclugen.main.clugen] function.\n    Note that the array is changed in-place.\n    Examples:\n        &gt;&gt;&gt; from numpy import array\n        &gt;&gt;&gt; from pyclugen import fix_empty\n        &gt;&gt;&gt; clusters = array([3, 4, 5, 0, 0])\n        &gt;&gt;&gt; fix_empty(clusters)\n        array([3, 3, 4, 1, 1])\n        &gt;&gt;&gt; clusters # Verify that the array was changed in-place\n        array([3, 3, 4, 1, 1])\n    Args:\n      clu_num_points: Number of points in each cluster (vector of size $c$),\n        where $c$ is the number of clusters.\n      allow_empty: Allow empty clusters?\n    Returns:\n      Number of points in each cluster, after being fixed by this function (vector\n        of size $c$, which is the same reference than `clu_num_points`).\n    \"\"\"\n# If the allow_empty parameter is set to true, don't do anything and return\n# immediately; this is useful for quick `clusizes_fn` one-liners\nif not allow_empty:\n# Find empty clusters\nempty_clusts = [idx for idx, val in enumerate(clu_num_points) if val == 0]\n# If there are empty clusters and enough points for all clusters...\nif len(empty_clusts) &gt; 0 and sum(clu_num_points) &gt;= clu_num_points.size:\n# Go through the empty clusters...\nfor i0 in empty_clusts:\n# ...get a point from the largest cluster and assign it to the\n# current empty cluster\nimax = argmax(clu_num_points)\nclu_num_points[imax] -= 1\nclu_num_points[i0] += 1\nreturn clu_num_points\n</code></pre>"},{"location":"reference/#pyclugen.fix_num_points","title":"fix_num_points","text":"<pre><code>fix_num_points(clu_num_points: NDArray, num_points: int) -&gt; NDArray\n</code></pre> <p>Certifies that the values in the <code>clu_num_points</code> array add up to <code>num_points</code>.</p> <p>If this is not the case, the <code>clu_num_points</code> array is modified in-place, incrementing the value corresponding to the smallest cluster while <code>sum(clu_num_points) &lt; num_points</code>, or decrementing the value corresponding to the largest cluster while <code>sum(clu_num_points) &gt; num_points</code>.</p> <p>This function is used internally by <code>clusizes()</code> and might be useful for custom cluster sizing implementations given as the <code>clusizes_fn</code> parameter of the main <code>clugen()</code> function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy import array\n&gt;&gt;&gt; from pyclugen import fix_num_points\n&gt;&gt;&gt; clusters = array([1, 6, 3])  # 10 total points\n&gt;&gt;&gt; fix_num_points(clusters, 12) # But we want 12 total points\narray([3, 6, 3])\n&gt;&gt;&gt; clusters # Verify that the array was changed in-place\narray([3, 6, 3])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>clu_num_points</code> <code>NDArray</code> <p>Number of points in each cluster (vector of size \\(c\\)), where \\(c\\) is the number of clusters.</p> required <code>num_points</code> <code>int</code> <p>The expected total number of points.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Number of points in each cluster, after being fixed by this function (vector of size \\(c\\), which is the same reference than <code>clu_num_points</code>).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/helper.py</code> <pre><code>def fix_num_points(clu_num_points: NDArray, num_points: int) -&gt; NDArray:\nr\"\"\"Certifies that the values in the `clu_num_points` array add up to `num_points`.\n    If this is not the case, the `clu_num_points` array is modified in-place,\n    incrementing the value corresponding to the smallest cluster while\n    `sum(clu_num_points) &lt; num_points`, or decrementing the value corresponding to\n    the largest cluster while `sum(clu_num_points) &gt; num_points`.\n    This function is used internally by [`clusizes()`][pyclugen.module.clusizes]\n    and might be useful for custom cluster sizing implementations given as the\n    `clusizes_fn` parameter of the main [`clugen()`][pyclugen.main.clugen] function.\n    Examples:\n        &gt;&gt;&gt; from numpy import array\n        &gt;&gt;&gt; from pyclugen import fix_num_points\n        &gt;&gt;&gt; clusters = array([1, 6, 3])  # 10 total points\n        &gt;&gt;&gt; fix_num_points(clusters, 12) # But we want 12 total points\n        array([3, 6, 3])\n        &gt;&gt;&gt; clusters # Verify that the array was changed in-place\n        array([3, 6, 3])\n    Args:\n      clu_num_points: Number of points in each cluster (vector of size $c$),\n        where $c$ is the number of clusters.\n      num_points: The expected total number of points.\n    Returns:\n      Number of points in each cluster, after being fixed by this function (vector\n        of size $c$, which is the same reference than `clu_num_points`).\n    \"\"\"\nwhile sum(clu_num_points) &lt; num_points:\nimin = argmin(clu_num_points)\nclu_num_points[imin] += 1\nwhile sum(clu_num_points) &gt; num_points:\nimax = argmax(clu_num_points)\nclu_num_points[imax] -= 1\nreturn clu_num_points\n</code></pre>"},{"location":"reference/#pyclugen.llengths","title":"llengths","text":"<pre><code>llengths(\nnum_clusters: int,\nllength: float,\nllength_disp: float,\nrng: Generator = _default_rng,\n) -&gt; NDArray\n</code></pre> <p>Determine length of cluster-supporting lines.</p> <p>Line lengths are determined using the folded normal distribution ( \\(\\mu=\\)<code>llength</code>, \\(\\sigma=\\)<code>llength_disp</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from numpy.random import Generator, MT19937\n&gt;&gt;&gt; from pyclugen import llengths\n&gt;&gt;&gt; prng = Generator(MT19937(123))\n&gt;&gt;&gt; llengths(4, 20, 3.5, rng=prng)\narray([19.50968733, 19.92482858, 25.99013804, 18.58029672])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_clusters</code> <code>int</code> <p>Number of clusters.</p> required <code>llength</code> <code>float</code> <p>Average line length.</p> required <code>llength_disp</code> <code>float</code> <p>Line length dispersion.</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Lengths of cluster-supporting lines (vector of size <code>num_clusters</code>).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/module.py</code> <pre><code>def llengths(\nnum_clusters: int,\nllength: float,\nllength_disp: float,\nrng: Generator = _default_rng,\n) -&gt; NDArray:\nr\"\"\"Determine length of cluster-supporting lines.\n    Line lengths are determined using the folded normal distribution (\n    $\\mu=$`llength`, $\\sigma=$`llength_disp`).\n    Examples:\n        &gt;&gt;&gt; from numpy.random import Generator, MT19937\n        &gt;&gt;&gt; from pyclugen import llengths\n        &gt;&gt;&gt; prng = Generator(MT19937(123))\n        &gt;&gt;&gt; llengths(4, 20, 3.5, rng=prng)\n        array([19.50968733, 19.92482858, 25.99013804, 18.58029672])\n    Args:\n      num_clusters: Number of clusters.\n      llength: Average line length.\n      llength_disp: Line length dispersion.\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Lengths of cluster-supporting lines (vector of size `num_clusters`).\n    \"\"\"\nreturn abs(llength + llength_disp * rng.normal(size=num_clusters))\n</code></pre>"},{"location":"reference/#pyclugen.points_on_line","title":"points_on_line","text":"<pre><code>points_on_line(\ncenter: NDArray, direction: NDArray, dist_center: NDArray\n) -&gt; NDArray\n</code></pre> <p>Determine coordinates of points on a line.</p> <p>Determine coordinates of points on a line with <code>center</code> and <code>direction</code>, based on the distances from the center given in <code>dist_center</code>.</p> <p>This works by using the vector formulation of the line equation assuming <code>direction</code> is a \\(n\\)-dimensional unit vector. In other words, considering \\(\\mathbf{d}=\\)<code>direction.reshape(-1,1)</code> ( \\(n \\times 1\\) vector), \\(\\mathbf{c}=\\)<code>center.reshape(-1,1)</code> ( \\(n \\times 1\\) vector), and \\(\\mathbf{w}=\\) <code>dist_center.reshape(-1,1)</code> ( \\(p \\times 1\\) vector), the coordinates of points on the line are given by:</p> \\[ \\mathbf{P}=\\mathbf{1}\\,\\mathbf{c}^T + \\mathbf{w}\\mathbf{d}^T \\] <p>where \\(\\mathbf{P}\\) is the \\(p \\times n\\) matrix of point coordinates on the line, and \\(\\mathbf{1}\\) is a \\(p \\times 1\\) vector with all entries equal to 1.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import points_on_line\n&gt;&gt;&gt; from numpy import array, linspace\n&gt;&gt;&gt; points_on_line(array([5., 5.]),\n...                array([1., 0.]),\n...                linspace(-4, 4, 5)) # 2D, 5 points\narray([[1., 5.],\n       [3., 5.],\n       [5., 5.],\n       [7., 5.],\n       [9., 5.]])\n&gt;&gt;&gt; points_on_line(array([-2, 0, 0., 2]),\n...                array([0., 0, -1, 0]),\n...                array([10, -10])) # 4D, 2 points\narray([[ -2.,   0., -10.,   2.],\n       [ -2.,   0.,  10.,   2.]])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>NDArray</code> <p>Center of the line ( \\(n\\)-component vector).</p> required <code>direction</code> <code>NDArray</code> <p>Line direction ( \\(n\\)-component unit vector).</p> required <code>dist_center</code> <code>NDArray</code> <p>Distance of each point to the center of the line ( \\(p\\)-component vector, where \\(p\\) is the number of points).</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of points on the specified line ( \\(p \\times n\\) matrix).</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/core.py</code> <pre><code>def points_on_line(\ncenter: NDArray, direction: NDArray, dist_center: NDArray\n) -&gt; NDArray:\nr\"\"\"Determine coordinates of points on a line.\n    Determine coordinates of points on a line with `center` and `direction`,\n    based on the distances from the center given in `dist_center`.\n    This works by using the vector formulation of the line equation assuming\n    `direction` is a $n$-dimensional unit vector. In other words, considering\n    $\\mathbf{d}=$`direction.reshape(-1,1)` ( $n \\times 1$ vector),\n    $\\mathbf{c}=$`center.reshape(-1,1)` ( $n \\times 1$ vector), and\n    $\\mathbf{w}=$ `dist_center.reshape(-1,1)` ( $p \\times 1$ vector),\n    the coordinates of points on the line are given by:\n    $$\n    \\mathbf{P}=\\mathbf{1}\\,\\mathbf{c}^T + \\mathbf{w}\\mathbf{d}^T\n    $$\n    where $\\mathbf{P}$ is the $p \\times n$ matrix of point coordinates on the\n    line, and $\\mathbf{1}$ is a $p \\times 1$ vector with all entries equal to 1.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import points_on_line\n        &gt;&gt;&gt; from numpy import array, linspace\n        &gt;&gt;&gt; points_on_line(array([5., 5.]),\n        ...                array([1., 0.]),\n        ...                linspace(-4, 4, 5)) # 2D, 5 points\n        array([[1., 5.],\n               [3., 5.],\n               [5., 5.],\n               [7., 5.],\n               [9., 5.]])\n        &gt;&gt;&gt; points_on_line(array([-2, 0, 0., 2]),\n        ...                array([0., 0, -1, 0]),\n        ...                array([10, -10])) # 4D, 2 points\n        array([[ -2.,   0., -10.,   2.],\n               [ -2.,   0.,  10.,   2.]])\n    Args:\n      center: Center of the line ( $n$-component vector).\n      direction: Line direction ( $n$-component unit vector).\n      dist_center: Distance of each point to the center of the line\n        ( $p$-component vector, where $p$ is the number of points).\n    Returns:\n      Coordinates of points on the specified line ( $p \\times n$ matrix).\n    \"\"\"\nreturn center.reshape(1, -1) + dist_center.reshape(-1, 1) @ direction.reshape(\n(1, -1)\n)\n</code></pre>"},{"location":"reference/#pyclugen.rand_ortho_vector","title":"rand_ortho_vector","text":"<pre><code>rand_ortho_vector(u: NDArray, rng: Generator = _default_rng) -&gt; NDArray\n</code></pre> <p>Get a random unit vector orthogonal to <code>u</code>.</p> <p>Note that <code>u</code> is expected to be a unit vector itself.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import rand_ortho_vector\n&gt;&gt;&gt; from numpy import isclose, dot\n&gt;&gt;&gt; from numpy.linalg import norm\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; rng = Generator(PCG64(123))\n&gt;&gt;&gt; r = rng.random(3) # Get a random vector with 3 components (3D)\n&gt;&gt;&gt; r = r / norm(r) # Normalize it\n&gt;&gt;&gt; r_ort = rand_ortho_vector(r, rng=rng) # Get random unit vector orth. to r\n&gt;&gt;&gt; r_ort\narray([-0.1982903 , -0.61401512,  0.76398062])\n&gt;&gt;&gt; isclose(dot(r, r_ort), 0) # Check that vectors are indeed orthogonal\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>NDArray</code> <p>Unit vector with \\(n\\) components.</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A random unit vector with \\(n\\) components orthogonal to <code>u</code>.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/core.py</code> <pre><code>def rand_ortho_vector(u: NDArray, rng: Generator = _default_rng) -&gt; NDArray:\nr\"\"\"Get a random unit vector orthogonal to `u`.\n    Note that `u` is expected to be a unit vector itself.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import rand_ortho_vector\n        &gt;&gt;&gt; from numpy import isclose, dot\n        &gt;&gt;&gt; from numpy.linalg import norm\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; rng = Generator(PCG64(123))\n        &gt;&gt;&gt; r = rng.random(3) # Get a random vector with 3 components (3D)\n        &gt;&gt;&gt; r = r / norm(r) # Normalize it\n        &gt;&gt;&gt; r_ort = rand_ortho_vector(r, rng=rng) # Get random unit vector orth. to r\n        &gt;&gt;&gt; r_ort\n        array([-0.1982903 , -0.61401512,  0.76398062])\n        &gt;&gt;&gt; isclose(dot(r, r_ort), 0) # Check that vectors are indeed orthogonal\n        True\n    Args:\n      u: Unit vector with $n$ components.\n      rng: Optional pseudo-random number generator.\n    Returns:\n      A random unit vector with $n$ components orthogonal to `u`.\n    \"\"\"\n# If 1D, just return a random unit vector\nif u.size == 1:\nreturn rand_unit_vector(1, rng=rng)\n# Find a random, non-parallel vector to u\nwhile True:\n# Find normalized random vector\nr = rand_unit_vector(u.size, rng=rng)\n# If not parallel to u we can keep it and break the loop\nif not isclose(abs(dot(u, r)), 1):\nbreak\n# Get vector orthogonal to u using 1st iteration of Gram-Schmidt process\nv = r - dot(u, r) / dot(u, u) * u\n# Normalize it\nv = v / norm(v)\n# And return it\nreturn v\n</code></pre>"},{"location":"reference/#pyclugen.rand_unit_vector","title":"rand_unit_vector","text":"<pre><code>rand_unit_vector(num_dims: int, rng: Generator = _default_rng) -&gt; NDArray\n</code></pre> <p>Get a random unit vector with <code>num_dims</code> components.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import rand_unit_vector\n&gt;&gt;&gt; rand_unit_vector(4)\narray([ 0.48653889,  0.50753862,  0.05711487, -0.70881757])\n</code></pre> <pre><code>&gt;&gt;&gt; from pyclugen import rand_unit_vector\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; rng = Generator(PCG64(123))\n&gt;&gt;&gt; rand_unit_vector(2, rng=rng) # Reproducible\narray([ 0.3783202 , -0.92567479])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>num_dims</code> <code>int</code> <p>Number of components in vector (i.e. vector size).</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A random unit vector with <code>num_dims</code> components.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/core.py</code> <pre><code>def rand_unit_vector(num_dims: int, rng: Generator = _default_rng) -&gt; NDArray:\nr\"\"\"Get a random unit vector with `num_dims` components.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import rand_unit_vector\n        &gt;&gt;&gt; rand_unit_vector(4) # doctest: +SKIP\n        array([ 0.48653889,  0.50753862,  0.05711487, -0.70881757])\n        &gt;&gt;&gt; from pyclugen import rand_unit_vector\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; rng = Generator(PCG64(123))\n        &gt;&gt;&gt; rand_unit_vector(2, rng=rng) # Reproducible\n        array([ 0.3783202 , -0.92567479])\n    Args:\n      num_dims: Number of components in vector (i.e. vector size).\n      rng: Optional pseudo-random number generator.\n    Returns:\n      A random unit vector with `num_dims` components.\n    \"\"\"\nr = rng.random(num_dims) - 0.5\nr = r / norm(r)\nreturn r\n</code></pre>"},{"location":"reference/#pyclugen.rand_vector_at_angle","title":"rand_vector_at_angle","text":"<pre><code>rand_vector_at_angle(\nu: NDArray, angle: float, rng: Generator = _default_rng\n) -&gt; NDArray\n</code></pre> <p>Get a random unit vector which is at <code>angle</code> radians of vector <code>u</code>.</p> <p>Note that <code>u</code> is expected to be a unit vector itself.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyclugen import rand_vector_at_angle\n&gt;&gt;&gt; from numpy import arccos, array, degrees, pi, dot\n&gt;&gt;&gt; from numpy.linalg import norm\n&gt;&gt;&gt; from numpy.random import Generator, PCG64\n&gt;&gt;&gt; rng = Generator(PCG64(123))\n&gt;&gt;&gt; u = array([ 1.0, 0, 0.5, -0.5 ]) # Define a 4D vector\n&gt;&gt;&gt; u = u / norm(u) # Normalize the vector\n&gt;&gt;&gt; v = rand_vector_at_angle(u, pi/4, rng=rng) # Get a vector at 45 degrees\n&gt;&gt;&gt; v\narray([ 0.633066  , -0.50953554, -0.10693823, -0.57285705])\n&gt;&gt;&gt; degrees(arccos(dot(u, v) / norm(u) * norm(v))) # Angle between u and v\n45.0\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>NDArray</code> <p>Unit vector with \\(n\\) components.</p> required <code>angle</code> <code>float</code> <p>Angle in radians.</p> required <code>rng</code> <code>Generator</code> <p>Optional pseudo-random number generator.</p> <code>_default_rng</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Random unit vector with \\(n\\) components which is at <code>angle</code> radians with vector <code>u</code>.</p> Source code in <code>/home/runner/.local/lib/python3.10/site-packages/pyclugen/core.py</code> <pre><code>def rand_vector_at_angle(\nu: NDArray, angle: float, rng: Generator = _default_rng\n) -&gt; NDArray:\nr\"\"\"Get a random unit vector which is at `angle` radians of vector `u`.\n    Note that `u` is expected to be a unit vector itself.\n    Examples:\n        &gt;&gt;&gt; from pyclugen import rand_vector_at_angle\n        &gt;&gt;&gt; from numpy import arccos, array, degrees, pi, dot\n        &gt;&gt;&gt; from numpy.linalg import norm\n        &gt;&gt;&gt; from numpy.random import Generator, PCG64\n        &gt;&gt;&gt; rng = Generator(PCG64(123))\n        &gt;&gt;&gt; u = array([ 1.0, 0, 0.5, -0.5 ]) # Define a 4D vector\n        &gt;&gt;&gt; u = u / norm(u) # Normalize the vector\n        &gt;&gt;&gt; v = rand_vector_at_angle(u, pi/4, rng=rng) # Get a vector at 45 degrees\n        &gt;&gt;&gt; v\n        array([ 0.633066  , -0.50953554, -0.10693823, -0.57285705])\n        &gt;&gt;&gt; degrees(arccos(dot(u, v) / norm(u) * norm(v))) # Angle between u and v\n        45.0\n    Args:\n      u: Unit vector with $n$ components.\n      angle: Angle in radians.\n      rng: Optional pseudo-random number generator.\n    Returns:\n      Random unit vector with $n$ components which is at `angle` radians\n        with vector `u`.\n    \"\"\"\nif isclose(abs(angle), pi / 2) and u.size &gt; 1:\nreturn rand_ortho_vector(u, rng=rng)\nelif -pi / 2 &lt; angle &lt; pi / 2 and u.size &gt; 1:\nv = u + rand_ortho_vector(u, rng=rng) * tan(angle)\nreturn v / norm(v)\nelse:\n# For |\u03b8| &gt; \u03c0/2 or the 1D case, simply return a random vector\nreturn rand_unit_vector(u.size, rng=rng)\n</code></pre>"},{"location":"theory/","title":"Theory","text":"<p>This section describes the theoretical framework of the clugen algorithm, starting with a general Overview, then moving on to a Detailed description.</p>"},{"location":"theory/#overview","title":"Overview","text":"<p>Clugen is an algorithm for generating multidimensional clusters. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. For brevity, line segments will be referred to as lines.</p> <p>Given an \\(n\\)-dimensional direction vector \\(\\mathbf{d}\\) (and a number of additional parameters, which will be discussed shortly), the clugen algorithm works as follows (\\(^*\\) means the algorithm step is stochastic):</p> <ol> <li>Normalize \\(\\mathbf{d}\\).</li> <li>\\(^*\\)Determine cluster sizes.</li> <li>\\(^*\\)Determine cluster centers.</li> <li>\\(^*\\)Determine lengths of cluster-supporting lines.</li> <li>\\(^*\\)Determine angles between \\(\\mathbf{d}\\) and cluster-supporting lines.</li> <li>For each cluster:</li> <li>\\(^*\\)Determine direction of the cluster-supporting line.</li> <li>\\(^*\\)Determine distance of point projections from the center of the       cluster-supporting line.</li> <li>Determine coordinates of point projections on the cluster-supporting line.</li> <li>\\(^*\\)Determine points from their projections on the cluster-supporting       line.</li> </ol> <p>Figure 1 provides a stylized overview of the algorithm's steps.</p> <p></p> <p>The example in Figure 1 was generated with the following parameters, the exact meaning of each will be discussed shortly:</p> Parameter values Description \\(n=2\\) Number of dimensions. \\(c=4\\) Number of clusters. \\(p=200\\) Total number of points. \\(\\mathbf{d}=\\begin{bmatrix}1 &amp; 1\\end{bmatrix}^T\\) Average direction. \\(\\theta_\\sigma=\\pi/16\\approx{}11.25^{\\circ}\\) Angle dispersion. \\(\\mathbf{s}=\\begin{bmatrix}10 &amp; 10\\end{bmatrix}^T\\) Average cluster separation. \\(l=10\\) Average line length. \\(l_\\sigma=1.5\\) Line length dispersion. \\(f_\\sigma=1\\) Cluster lateral dispersion. <p>Additionally, all optional parameters (not listed above) were left to their default values. These will also be discussed next.</p>"},{"location":"theory/#detailed-description","title":"Detailed description","text":"<p>In this section we provide a detailed description of the algorithm and its parameters. We start by listing and describing all parameters (mandatory and optional), and then analyze the algorithm in detail, highlighting how each parameter influences the end result.</p>"},{"location":"theory/#algorithm-parameters","title":"Algorithm parameters","text":"<p>The clugen algorithm (and consequently, the <code>clugen()</code> function) has mandatory and optional parameters, listed and described in the tables below. The optional parameters are set to sensible defaults, and in many situations may be left unchanged. Nonetheless, these allow all of the algorithm's steps to be fully customized by the user.</p>"},{"location":"theory/#mandatory-parameters","title":"Mandatory parameters","text":"Symbol Parameter Description \\(n\\) <code>num_dims</code> Number of dimensions. \\(c\\) <code>num_clusters</code> Number of clusters. \\(p\\) <code>num_points</code> Total number of points to generate. \\(\\mathbf{d}\\) <code>direction</code> Average direction of cluster-supporting lines (\\(n \\times 1\\)). \\(\\theta_\\sigma\\) <code>angle_disp</code> Angle dispersion of cluster-supporting lines (radians). \\(\\mathbf{s}\\) <code>cluster_sep</code> Average cluster separation in each dimension (\\(n \\times 1\\)). \\(l\\) <code>llength</code> Average length of cluster-supporting lines. \\(l_\\sigma\\) <code>llength_disp</code> Length dispersion of cluster-supporting lines. \\(f_\\sigma\\) <code>lateral_disp</code> Cluster lateral dispersion, i.e., dispersion of points from their projection on the cluster-supporting line."},{"location":"theory/#optional-parameters","title":"Optional parameters","text":"Symbol Parameter Default value Description \\(\\phi\\) <code>allow_empty</code> <code>False</code> Allow empty clusters? \\(\\mathbf{o}\\) <code>cluster_offset</code> <code>zeros(num_dims)</code> Offset to add to all cluster centers (\\(n \\times 1\\)). \\(p_\\text{proj}()\\) <code>proj_dist_fn</code> <code>\"norm\"</code> Distribution of point projections along cluster-supporting lines. \\(p_\\text{final}()\\) <code>point_dist_fn</code> <code>\"n-1\"</code> Distribution of final points from their projections. \\(c_s()\\) <code>clusizes_fn</code> <code>clusizes()</code> Distribution of cluster sizes. \\(c_c()\\) <code>clucenters_fn</code> <code>clucenters()</code> Distribution of cluster centers. \\(l()\\) <code>llengths_fn</code> <code>llengths()</code> Distribution of line lengths. \\(\\theta_\\Delta()\\) <code>angle_deltas_fn</code> <code>angle_deltas()</code> Distribution of line angle deltas (w.r.t. \\(\\mathbf{d}\\))."},{"location":"theory/#the-algorithm-in-detail","title":"The algorithm in detail","text":"<p>The clugen algorithm is presented in Overview. In this section we will analyze each of the algorithms steps in detail.</p>"},{"location":"theory/#1-normalize-mathbfd","title":"1. Normalize \\(\\mathbf{d}\\)","text":"<p>This is a basic step, which consists of converting \\(\\mathbf{d}\\) to a unit vector:</p> \\[ \\hat{\\mathbf{d}} = \\cfrac{\\mathbf{d}}{\\left\\lVert\\mathbf{d}\\right\\rVert} \\]"},{"location":"theory/#2-determine-cluster-sizes","title":"2. Determine cluster sizes","text":"<p>Cluster sizes are given by the \\(c_s()\\) function according to:</p> \\[ \\mathbf{c_s} = c_s(c, p, \\phi) \\] <p>where \\(\\mathbf{c_s}\\) is an \\(c \\times 1\\) integer vector containing the final cluster sizes, \\(c\\) is the number of clusters, \\(p\\) is the total number of points, and \\(\\phi\\) is a boolean which determines whether empty clusters are acceptable.</p> <p>The \\(c_s()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(c_s()\\) is implemented by the <code>clusizes()</code> function, which behaves according to the following algorithm:</p> <ol> <li>Determine the size \\(p_i\\) of each cluster \\(i\\) according to    \\(p_i\\sim\\left\\lfloor\\max\\left(\\mathcal{N}(\\frac{p}{c}, (\\frac{p}{3c})^2),0\\right)\\right\\rceil\\),    where \\(\\lfloor\\rceil\\) denotes the round to nearest integer function, and     \\(\\mathcal{N}(\\mu,\\sigma^2)\\) represents the normal distribution with    mean \\(\\mu\\) and variance \\(\\sigma^2\\).</li> <li>Assure that the final cluster sizes add up to \\(p\\) by incrementing the smallest    cluster size while \\(\\sum_{i=1}^c p_i&lt;p\\) or decrementing the largest cluster    size while \\(\\sum_{i=1}^c p_i&gt;p\\). This step is delegated to the    <code>fix_num_points()</code> helper function.</li> <li>If \\(\\neg\\phi\\wedge p\\ge c\\) then, for each empty cluster \\(i\\) (i.e.,    \\(p_i=0\\)), increment \\(p_i\\) and decrement \\(p_j\\), where \\(j\\) denotes the    largest cluster. This step is delegated to the    <code>fix_empty()</code> helper function.</li> </ol> <p>Figure 2 demonstrates possible cluster sizes with various definitions of \\(c_s()\\) for \\(c=4\\) and \\(p=5000\\). The default behavior, implemented in the <code>clusizes()</code> function, is shown in Figure 2a, while Figures 2b-d present results obtained with custom user functions. Figure 2b displays cluster sizes obtained with the discrete uniform distribution over \\(\\left\\{1, 2, \\ldots, \\frac{2p}{c}\\right\\}\\), corrected with <code>fix_num_points()</code>. In turn, Figure 2c highlights cluster sizes obtained with the Poisson distribution with \\(\\lambda=\\frac{p}{c}\\), also corrected with <code>fix_num_points()</code>. The cluster sizes shown in Figure 2d were determined with the same distribution (Poisson, \\(\\lambda=\\frac{p}{c}\\)), but were not corrected. Thus, cluster sizes do not add up to \\(p\\), highlighting the fact that this is not a requirement of the clugen algorithm, i.e., user-defined  \\(c_s()\\) implementations can consider \\(p\\) a hint rather than an obligation.</p> <p></p>"},{"location":"theory/#3-determine-cluster-centers","title":"3. Determine cluster centers","text":"<p>Cluster sizes are given by the \\(c_c()\\) function according to:</p> \\[ \\mathbf{C} = c_c(c, \\mathbf{s}, \\mathbf{o}) \\] <p>where \\(\\mathbf{C}\\) is an \\(c \\times n\\) matrix containing the final cluster centers, \\(c\\) is the number of clusters, \\(\\mathbf{s}\\) is the average cluster separation (\\(n \\times 1\\) vector), and \\(\\mathbf{o}\\) is an \\(n \\times 1\\) vector of cluster offsets.</p> <p>The \\(c_c()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(c_c()\\) is implemented by the <code>clucenters()</code> function, which determines the cluster centers according to:</p> \\[ \\mathbf{C}=c\\mathbf{U} \\cdot \\operatorname{diag}(\\mathbf{s}) + \\mathbf{1}\\,\\mathbf{o}^T \\] <p>where \\(\\mathbf{U}\\) is an \\(c \\times n\\) matrix of random values drawn from the uniform distribution between -0.5 and 0.5, and \\(\\mathbf{1}\\) is an \\(c \\times 1\\) vector with all entries equal to 1.</p> <p>Figure 3 shows scatters plots of the results generated by clugen for two different implementations of the \\(c_c()\\) function, namely using the uniform the distribution (the default, implemented by the <code>clucenters()</code> function, Figure 3a), and direct specification of cluster centers (Figure 3b).</p> <p></p>"},{"location":"theory/#4-determine-lengths-of-cluster-supporting-lines","title":"4. Determine lengths of cluster-supporting lines","text":"<p>The lengths of the cluster-supporting lines are given by the \\(l()\\) function according to:</p> \\[ \\pmb{\\ell} = l(c, l, l_\\sigma) \\] <p>where \\(\\pmb{\\ell}\\) is an \\(c \\times 1\\) vector containing the final lengths of the cluster-supporting lines, \\(c\\) is the number of clusters, \\(l\\) is the average length, and \\(l_\\sigma\\) is the length dispersion.</p> <p>The \\(l()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(l()\\) is implemented by the <code>llengths()</code> function, which determines the \\(\\ell_i\\) length of each cluster-supporting line \\(i\\) according to:</p> \\[ \\ell_i\\sim\\left|\\mathcal{N}(l,l_\\sigma^2)\\right| \\] <p>where \\(\\left|\\mathcal{N}(\\mu,\\sigma^2)\\right|\\) represents the folded normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\).</p> <p>Figure 4 shows cluster-supporting line lengths obtained with different implementations of \\(l()\\).</p> <p></p>"},{"location":"theory/#5-determine-angles-between-mathbfd-and-cluster-supporting-lines","title":"5. Determine angles between \\(\\mathbf{d}\\) and cluster-supporting lines","text":"<p>The angles between \\(\\mathbf{d}\\) and the cluster-supporting lines are given by the \\(\\theta_\\Delta()\\) function according to:</p> \\[ \\mathbf{\\Theta_\\Delta} = \\theta_\\Delta(c, \\theta_\\sigma) \\] <p>where \\(\\mathbf{\\Theta_\\Delta}\\) is an \\(c \\times 1\\) vector containing the final angle differences between \\(\\mathbf{d}\\) and the cluster-supporting lines, \\(c\\) is the number of clusters, and \\(\\theta_\\sigma\\) is the angle dispersion.</p> <p>The \\(\\theta_\\Delta()\\) function is an optional parameter, allowing users to customize its behavior. By default, \\(\\theta_\\Delta()\\) is implemented by the <code>angle_deltas()</code> function, which determines the \\(\\theta_{\\Delta i}\\) angle difference between \\(\\mathbf{d}\\) and the \\(i\\)-th cluster-supporting line according to:</p> \\[ \\theta_{\\Delta i}\\sim\\mathcal{WN}_{-\\pi/2}^{\\pi/2}(0,\\theta_\\sigma^2) \\] <p>where \\(\\mathcal{WN}_{-\\pi/2}^{\\pi/2}(\\mu,\\sigma^2)\\) represents the wrapped normal distribution with mean \\(\\mu\\), variance \\(\\sigma^2\\), and support in the \\(\\left[-\\pi/2,\\pi/2\\right]\\) interval, and \\(\\theta_\\sigma\\) is the angle dispersion of the cluster-supporting lines.</p> <p>Figure 5 shows the final direction of the cluster-supporting lines for two different implementations of \\(\\theta_\\Delta()\\).</p> <p></p>"},{"location":"theory/#6-for-each-cluster-i","title":"6. For each cluster \\(i\\):","text":""},{"location":"theory/#61-determine-direction-of-the-cluster-supporting-line","title":"6.1. Determine direction of the cluster-supporting line","text":"<p>In order to obtain the \\(\\hat{\\mathbf{d}}_i\\) final direction of cluster \\(i\\) supporting line, the following algorithm is used:</p> <ul> <li>1. Find random vector \\(\\mathbf{r}\\) with each component taken from the   uniform distribution between -0.5 and 0.5.</li> <li>2. Normalize \\(\\mathbf{r}\\):</li> </ul> \\[ \\hat{\\mathbf{r}}=\\cfrac{\\mathbf{r}}{\\left\\lVert\\mathbf{r}\\right\\rVert} \\] <ul> <li>3. If \\(|\\theta_{\\Delta i}| &gt; \\pi/2\\) or \\(n=1\\), set   \\(\\hat{\\mathbf{d}}_i=\\hat{\\mathbf{r}}\\) and terminate the algorithm.</li> <li>4. If \\(\\hat{\\mathbf{r}}\\) is parallel to \\(\\hat{\\mathbf{d}}\\) go to 1.</li> <li>5. Determine vector \\(\\mathbf{d}_\\perp\\) orthogonal to \\(\\hat{\\mathbf{d}}\\)   using the first iteration of the Gram-Schmidt process:</li> </ul> \\[ \\mathbf{d}_\\perp=\\hat{\\mathbf{r}}-\\cfrac{\\hat{\\mathbf{d}}\\cdot\\hat{\\mathbf{r}}}{\\hat{\\mathbf{d}}\\cdot\\hat{\\mathbf{d}}}\\:\\hat{\\mathbf{d}} \\] <ul> <li>6. Normalize \\(\\mathbf{d}_\\perp\\):</li> </ul> \\[ \\hat{\\mathbf{d}}_\\perp=\\cfrac{\\mathbf{d}_\\perp}{\\left\\lVert\\mathbf{d}_\\perp\\right\\rVert} \\] <ul> <li>7. Determine vector \\(\\mathbf{d}_i\\) at angle \\(\\theta_{\\Delta i}\\) with   \\(\\hat{\\mathbf{d}}\\):</li> </ul> \\[ \\mathbf{d}_i=\\hat{\\mathbf{d}}+\\tan(\\theta_{\\Delta i})\\hat{\\mathbf{d}}_\\perp \\] <ul> <li>8. Normalize \\(\\mathbf{d}_i\\):</li> </ul> \\[ \\hat{\\mathbf{d}}_i=\\cfrac{\\mathbf{d}_i}{\\left\\lVert\\mathbf{d}_i\\right\\rVert} \\]"},{"location":"theory/#62-determine-distance-of-point-projections-from-the-center-of-the-cluster-supporting-line","title":"6.2. Determine distance of point projections from the center of the cluster-supporting line","text":"<p>The distance of point projections from the center of the cluster-supporting line is given by the \\(p_\\text{proj}()\\) function according to:</p> \\[ \\mathbf{w}_i = p_\\text{proj}(\\ell_i, p_i) \\] <p>where \\(\\mathbf{w}_i\\) is an \\(p_i \\times 1\\) vector containing the distance of each point projection to the center of the line, while \\(\\ell_i\\) and \\(p_i\\) are the line length and number of points in cluster \\(i\\), respectively.</p> <p>The \\(p_\\text{proj}()\\) function is an optional parameter, allowing users to customize its behavior. <code>pyclugen</code> provides two concrete implementations out of the box, specified by passing <code>\"norm\"</code> or <code>\"unif\"</code> to <code>clugen()</code>'s <code>proj_dist_fn</code> parameter. These work as follows:</p> <ul> <li><code>\"norm\"</code> (default) - Each element of \\(\\mathbf{w}_i\\) is derived from   \\(\\mathcal{N}(0, (\\frac{\\ell_i}{6})^2)\\), i.e., from the normal distribution,   centered on the cluster-supporting line center (\\(\\mu=0\\)) and with a standard   deviation of \\(\\sigma=\\frac{\\ell_i}{6}\\), such that the length of the line   segment encompasses \\(\\approx\\) 99.73% of the generated projections. Consequently,   some projections may be placed outside the line's end points.</li> <li><code>\"unif\"</code> - Each element of \\(\\mathbf{w}_i\\) is derived from   \\(\\mathcal{U}(-\\frac{\\ell_i}{2}, \\frac{\\ell_i}{2})\\), i.e., from the continuous   uniform distribution in the interval \\(\\left[-\\frac{\\ell_i}{2}, \\frac{\\ell_i}{2}\\right[\\).   Thus, projections will be uniformly dispersed along the cluster-supporting line.</li> </ul> <p>The impact of various implementations of \\(p_\\text{proj}()\\) is demonstrated in Figure 6. Figures 6a and 6b show the clusters generated with the <code>\"norm\"</code> and <code>\"unif\"</code> options, respectively, while Figures 6c and 6d highlight custom user functions implementing the Laplace and Rayleigh distributions, respectively. All parameters are set as in Figure 1, except for \\(p_\\text{proj}()\\) in the case of Figures 6b-6d, and \\(p\\), which is set to 5000.</p> <p></p>"},{"location":"theory/#63-determine-coordinates-of-point-projections-on-the-cluster-supporting-line","title":"6.3. Determine coordinates of point projections on the cluster-supporting line","text":"<p>This is a deterministic step performed by the <code>points_on_line()</code> function using the vector formulation of the line equation, as follows:</p> \\[ \\mathbf{P}_i^\\text{proj}=\\mathbf{1}\\,\\mathbf{c}_i^T + \\mathbf{w}_i\\hat{\\mathbf{d}}_i^T \\] <p>where \\(\\mathbf{P}_i^\\text{proj}\\) is the \\(p_i \\times n\\) matrix of point projection coordinates on the line, \\(\\mathbf{1}\\) is an \\(p_i \\times 1\\) vector with all entries equal to 1, \\(\\mathbf{c}_i\\) are the coordinates of the line center (\\(n \\times 1\\) vector), \\(\\mathbf{w}_i\\) is the distance of each point projection to the center of the line (\\(p_i \\times 1\\) vector obtained in the previous step), and \\(\\hat{\\mathbf{d}}_i\\) is the direction of the cluster-supporting line for cluster \\(i\\).</p>"},{"location":"theory/#64-determine-points-from-their-projections-on-the-cluster-supporting-line","title":"6.4. Determine points from their projections on the cluster-supporting line","text":"<p>The final cluster points, obtained from their projections on the cluster-supporting line, are given by the \\(p_\\text{final}()\\) function according to:</p> \\[ \\mathbf{P}_i^\\text{final} = p_\\text{final}(\\mathbf{P}_i^\\text{proj}, f_\\sigma, \\ell_i, \\hat{\\mathbf{d}}_i, \\mathbf{c}_i) \\] <p>where \\(\\mathbf{P}_i^\\text{final}\\) is a \\(p_i \\times n\\) matrix containing the coordinates of the generated points, \\(\\mathbf{P}_i^\\text{proj}\\) is the \\(p_i \\times n\\) matrix of projection coordinates (determined in the previous step), and \\(f_\\sigma\\) is the lateral dispersion parameter. In turn, \\(\\ell_i\\), \\(\\hat{\\mathbf{d}}_i\\) and \\(\\mathbf{c}_i\\) are the length, direction and center of the cluster-supporting line.</p> <p>The \\(p_\\text{final}()\\) function is an optional parameter, allowing users to customize its behavior. <code>pyclugen</code> provides two concrete implementations out of the box, specified by passing <code>\"n-1\"</code> or <code>\"n\"</code> to <code>clugen()</code>'s <code>point_dist_fn</code> parameter. These work as follows:</p> <ul> <li><code>\"n-1\"</code> (default) - Points are placed on a hyperplane orthogonal to the   cluster-supporting line and intersecting the point's projection. This is done   by obtaining \\(p_i\\) random unit vectors orthogonal to \\(\\hat{\\mathbf{d}}_i\\),   and determining their magnitude using the normal distribution   (\\(\\mu=0\\), \\(\\sigma=f_\\sigma\\)). These vectors are then added to the respective   projections on the cluster-supporting line, yielding the final cluster points.   This behavior is implemented in the <code>clupoints_n_1()</code>   function.</li> <li><code>\"n\"</code> - Points are placed around their respective projections. This is done by   obtaining \\(p_i\\) random unit vectors, and determining their magnitude using   the normal distribution (\\(\\mu=0\\), \\(\\sigma=f_\\sigma\\)). These vectors are   then added to the respective projections on the cluster-supporting line,   yielding the final cluster points. This behavior is implemented in the   <code>clupoints_n()</code> function.</li> </ul> <p>Figure 7 highlights the differences between these two approaches in 2D, where a hyperplane is simply a line.</p> <p></p> <p>In general, points can be placed using a <code>\"n-1\"</code> or <code>\"n\"</code> strategy using any distribution. Figure 8 displays several examples for various implementations of \\(p_\\text{final}()\\), either based on <code>\"n-1\"</code> or <code>\"n\"</code> strategy, using different distributions. Figures 8a and 8b show the built-in <code>\"n-1\"</code> and <code>\"n\"</code> strategies making use of the normal distribution. Figures 8c-8f highlight some possibilities with custom user functions. Figure 8c shows the effect of using the exponential distribution in a <code>\"n-1\"</code> strategy, while Figure 8d displays the result of using a bimodal distribution with the same strategy. A more complex distribution, producing \"hollow\" clusters with a <code>\"n\"</code> strategy, is employed in Figures 8e and 8f, with the latter also having the \\(p_\\text{proj}()\\) function set to <code>\"unif\"</code>. The remaining parameters (for all subfigures) are set as in Figure 1, except for \\(p\\), which is set to 5000.</p> <p></p>"},{"location":"generated/gallery/","title":"Examples","text":""},{"location":"generated/gallery/#examples","title":"Examples","text":"<p> Examples in 1D </p> <p> Examples in 2D </p> <p> Examples in 3D </p> <p> Examples in nD </p> <p> Merging and hierarchical cluster examples </p> <p> Plot functions </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:29.945 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------------------------------+-----------+--------+ | plot_2_2d_examples (docs/examples/plot_2_2d_examples.py)    | 00:10.999 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_4_nd_examples (docs/examples/plot_4_nd_examples.py)    | 00:08.496 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_3_3d_examples (docs/examples/plot_3_3d_examples.py)    | 00:05.484 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_5_mrg_examples (docs/examples/plot_5_mrg_examples.py) | 00:03.471 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_1_1d_examples (docs/examples/plot_1_1d_examples.py)    | 00:01.489 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_functions (docs/examples/plot_functions.py)                | 00:00.006 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_1_1d_examples/","title":"Examples in 1D","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_1_1d_examples/#examples-in-1d","title":"Examples in 1D","text":"<p>This section contains several examples on how to generate 1D data with pyclugen. To run the examples we first need to import the <code>clugen()</code> function:</p> <pre><code>from pyclugen import clugen\n</code></pre> <p>To make the examples exactly reproducible we'll import a random number generator from NumPy and pass it as a parameter to <code>clugen()</code>. We'll also create a small helper function for providing us a brand new seeded generator:</p> <pre><code>import numpy as np\nfrom numpy.random import PCG64, Generator\ndef rng(seed):\nreturn Generator(PCG64(seed))\n</code></pre> <p>To plot these examples we use the <code>plot_examples_1d</code> function:</p> <pre><code>from plot_functions import plot_examples_1d\n</code></pre>"},{"location":"generated/gallery/plot_1_1d_examples/#basic-1d-example-with-density-plot","title":"Basic 1D example with density plot","text":"<pre><code>seed = 23456\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Weibull distribution\ndef proj_weibull(len, n, rng):\nreturn len / 2 * rng.weibull(1.5, size=n)\n</code></pre> <pre><code>e082 = clugen(1, 3, 1000, [1], 0, [10], 6, 1.5, 0, rng=rng(seed))\ne083 = clugen(1, 3, 1000, [1], 0, [10], 6, 1.5, 0, rng=rng(seed), proj_dist_fn=\"unif\")\ne084 = clugen(1, 3, 1000, [1], 0, [10], 6, 1.5, 0, rng=rng(seed), proj_dist_fn=proj_weibull)\n</code></pre> <pre><code>plot_examples_1d(\ne082, \"e082: proj_dist_fn = 'norm' (default)\",\ne083, \"e083: proj_dist_fn = 'unif'\",\ne084, \"e084: custom proj_dist_fn (Weibull)\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.489 seconds)</p> <p> Download Python source code: plot_1_1d_examples.py</p> <p> Download Jupyter notebook: plot_1_1d_examples.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_2_2d_examples/","title":"Examples in 2D","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_2_2d_examples/#examples-in-2d","title":"Examples in 2D","text":"<p>This section contains several examples on how to generate 2D data with pyclugen. To run the examples we first need to import the <code>clugen()</code> function:</p> <pre><code>from pyclugen import clugen\n</code></pre> <p>To make the examples exactly reproducible we'll import a random number generator from NumPy and pass it as a parameter to <code>clugen()</code>. We'll also create a small helper function for providing us a brand new seeded generator:</p> <pre><code>import numpy as np\nfrom numpy.random import PCG64, Generator\ndef rng(seed):\nreturn Generator(PCG64(seed))\n</code></pre> <p>To plot these examples we use the <code>plot_examples_2d</code> function:</p> <pre><code>from plot_functions import plot_examples_2d\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#manipulating-the-direction-of-cluster-supporting-lines","title":"Manipulating the direction of cluster-supporting lines","text":""},{"location":"generated/gallery/plot_2_2d_examples/#using-the-direction-parameter","title":"Using the <code>direction</code> parameter","text":"<pre><code>seed = 123\n</code></pre> <pre><code>e001 = clugen(2, 4, 2000, [1, 0], 0, [10, 10], 10, 1.5, 0.5, rng=rng(seed))\ne002 = clugen(2, 4, 200, [1, 1], 0, [10, 10], 10, 1.5, 0.5, rng=rng(seed))\ne003 = clugen(2, 4, 200, [0, 1], 0, [10, 10], 10, 1.5, 0.5, rng=rng(seed))\n</code></pre> <pre><code>plot_examples_2d(\ne001, \"e001: direction = [1, 0]\",\ne002, \"e002: direction = [1, 1]\",\ne003, \"e003: direction = [0, 1]\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function","title":"Changing the <code>angle_disp</code> parameter and using a custom <code>angle_deltas_fn</code> function","text":"<pre><code>seed = 321\n</code></pre> <pre><code># Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\ndef angdel_90_fn(nclu, astd, rng):\nreturn rng.choice([0, np.pi / 2], size=nclu)\n</code></pre> <pre><code>e004 = clugen(2, 6, 500, [1, 0], 0, [10, 10], 10, 1.5, 0.5, rng=rng(seed))\ne005 = clugen(2, 6, 500, [1, 0], np.pi / 8, [10, 10], 10, 1.5, 0.5, rng=rng(seed))\ne006 = clugen(2, 6, 500, [1, 0], 0, [10, 10], 10, 1.5, 0.5, rng=rng(seed),\nangle_deltas_fn=angdel_90_fn)\n</code></pre> <pre><code>plot_examples_2d(\ne004, \"e004: angle_disp = 0\",\ne005, \"e005: angle_disp = \u03c0/8\",\ne006, \"e006: custom angle_deltas function\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#manipulating-the-length-of-cluster-supporting-lines","title":"Manipulating the length of cluster-supporting lines","text":""},{"location":"generated/gallery/plot_2_2d_examples/#using-the-llength-parameter","title":"Using the <code>llength</code> parameter","text":"<pre><code>seed = 567\n</code></pre> <pre><code>e007 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10],  0, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne008 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10], 10, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne009 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10], 30, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\n</code></pre> <pre><code>plot_examples_2d(\ne007, \"e007: llength = 0\",\ne008, \"e008: llength = 10\",\ne009, \"e009: llength = 30\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function","title":"Changing the <code>llength_disp</code> parameter and using a custom <code>llengths_fn</code> function","text":"<pre><code>seed = 567\n</code></pre> <pre><code># Custom llengths function: line lengths grow for each new cluster\ndef llen_grow_fn(nclu, llen, llenstd, rng):\nreturn llen * np.arange(nclu) + rng.normal(scale=llenstd, size=nclu)\n</code></pre> <pre><code>e010 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10], 15,  0.0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne011 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10], 15, 10.0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne012 = clugen(2, 5, 800, [1, 0], np.pi / 10, [10, 10], 10,  0.1, 0.5, rng=rng(seed),\nllengths_fn=llen_grow_fn, point_dist_fn=\"n\")\n</code></pre> <pre><code>plot_examples_2d(\ne010, \"e010: llength_disp = 0.0\",\ne011, \"e011: llength_disp = 5.0\",\ne012, \"e012: custom llengths function\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#manipulating-relative-cluster-positions","title":"Manipulating relative cluster positions","text":""},{"location":"generated/gallery/plot_2_2d_examples/#using-the-cluster_sep-parameter","title":"Using the <code>cluster_sep</code> parameter","text":"<pre><code>seed = 21\n</code></pre> <pre><code>e013 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [10, 10], 10, 2, 2.5, rng=rng(seed))\ne014 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [30, 10], 10, 2, 2.5, rng=rng(seed))\ne015 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [10, 30], 10, 2, 2.5, rng=rng(seed))\n</code></pre> <pre><code>plt = plot_examples_2d(\ne013, \"e013: cluster_sep = [10, 10]\",\ne014, \"e014: cluster_sep = [30, 10]\",\ne015, \"e015: cluster_sep = [10, 30]\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function","title":"Changing the <code>cluster_offset</code> parameter and using a custom <code>clucenters_fn</code> function","text":"<pre><code>seed = 21\n</code></pre> <pre><code># Custom clucenters function: places clusters in a diagonal\ndef centers_diag_fn(nclu, csep, coff, rng):\nreturn np.ones((nclu, len(csep))) * np.arange(1, nclu + 1)[:, None] * np.max(csep) + coff\n</code></pre> <pre><code>e016 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [10, 10], 10, 2, 2.5, rng=rng(seed))\ne017 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [10, 10], 10, 2, 2.5, rng=rng(seed),\ncluster_offset=[20, -20])\ne018 = clugen(2, 8, 1000, [1, 1], np.pi / 4, [10, 10], 10, 2, 2.5, rng=rng(seed),\ncluster_offset=[-50, -50], clucenters_fn=centers_diag_fn)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne016, \"e016: default\",\ne017, \"e017: cluster_offset = [20, -20]\",\ne018, \"e018: custom clucenters function\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#lateral-dispersion-and-placement-of-point-projections-on-the-line","title":"Lateral dispersion and placement of point projections on the line","text":""},{"location":"generated/gallery/plot_2_2d_examples/#normal-projection-placement-default-proj_dist_fn-norm","title":"Normal projection placement (default): <code>proj_dist_fn = \"norm\"</code>","text":"<pre><code>seed = 654\n</code></pre> <pre><code>e019 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 0.0, rng=rng(seed))\ne020 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 1.0, rng=rng(seed))\ne021 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 3.0, rng=rng(seed))\n</code></pre> <pre><code>plt = plot_examples_2d(\ne019, \"e019: lateral_disp = 0\",\ne020, \"e020: lateral_disp = 1\",\ne021, \"e021: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#uniform-projection-placement-proj_dist_fn-unif","title":"Uniform projection placement: <code>proj_dist_fn = \"unif\"</code>","text":"<pre><code>seed = 654\n</code></pre> <pre><code>e022 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 0.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne023 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 1.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne024 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 3.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\n</code></pre> <pre><code>plt = plot_examples_2d(\ne022, \"e022: lateral_disp = 0\",\ne023, \"e023: lateral_disp = 1\",\ne024, \"e024: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#custom-projection-placement-using-the-laplace-distribution","title":"Custom projection placement using the Laplace distribution","text":"<pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e025 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 0.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\ne026 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 1.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\ne027 = clugen(2, 4, 1000, [1, 0], np.pi / 2, [20, 20], 13, 2, 3.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne025, \"e025: lateral_disp = 0\",\ne026, \"e026: lateral_disp = 1\",\ne027, \"e027: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line","title":"Controlling final point positions from their projections on the cluster-supporting line","text":""},{"location":"generated/gallery/plot_2_2d_examples/#points-on-hyperplane-orthogonal-to-cluster-supporting-line-default-point_dist_fn-n-1","title":"Points on hyperplane orthogonal to cluster-supporting line (default): <code>point_dist_fn = \"n-1\"</code>","text":"<pre><code>seed = 1357\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e028 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed))\ne029 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne030 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne028, \"e028: proj_dist_fn=\\\"norm\\\" (default)\",\ne029, \"e029: proj_dist_fn=\\\"unif\\\"\",\ne030, \"e030: custom proj_dist_fn (Laplace)\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#points-around-projection-on-cluster-supporting-line-point_dist_fn-n","title":"Points around projection on cluster-supporting line: <code>point_dist_fn = \"n\"</code>","text":"<pre><code>seed = 1357\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e031 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=\"n\")\ne032 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=\"n\", proj_dist_fn=\"unif\")\ne033 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=\"n\", proj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne031, \"e031: proj_dist_fn=\\\"norm\\\" (default)\",\ne032, \"e032: proj_dist_fn=\\\"unif\\\"\",\ne033, \"e033: custom proj_dist_fn (Laplace)\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#custom-point-placement-using-the-exponential-distribution","title":"Custom point placement using the exponential distribution","text":"<p>For this example we require the <code>clupoints_n_1_template()</code> helper function:</p> <pre><code>from pyclugen import clupoints_n_1_template\n</code></pre> <pre><code>seed = 1357\n</code></pre> <pre><code># Custom point_dist_fn: final points placed using the Exponential distribution\ndef clupoints_n_1_exp(projs, lat_std, len, clu_dir, clu_ctr, rng):\ndef dist_exp(npts, lstd, rg):\nreturn lstd * rg.exponential(scale=2 / lstd, size=npts)\nreturn clupoints_n_1_template(projs, lat_std, clu_dir, dist_exp, rng=rng)\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e034 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp)\ne035 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp, proj_dist_fn=\"unif\")\ne036 = clugen(2, 5, 1500, [1, 0], np.pi / 3, [20, 20], 12, 3, 1.0, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp, proj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne034, \"e034: proj_dist_fn=\\\"norm\\\" (default)\",\ne035, \"e035: proj_dist_fn=\\\"unif\\\"\",\ne036, \"e036: custom proj_dist_fn (Laplace)\")\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_2_2d_examples/#manipulating-cluster-sizes","title":"Manipulating cluster sizes","text":"<pre><code>seed = 963\n</code></pre> <pre><code># Custom clusizes_fn (e038): cluster sizes determined via the uniform distribution,\n# no correction for total points\ndef clusizes_unif(nclu, npts, ae, rng):\nreturn rng.integers(low=1, high=2 * npts / nclu + 1, size=nclu)\n</code></pre> <pre><code># Custom clusizes_fn (e039): clusters all have the same size, no correction for total points\ndef clusizes_equal(nclu, npts, ae, rng):\nreturn (npts // nclu) * np.ones(nclu, dtype=int)\n</code></pre> <pre><code># Custom clucenters_fn (all): yields fixed positions for the clusters\ndef centers_fixed(nclu, csep, coff, rng):\nreturn np.array([[-csep[0], -csep[1]], [csep[0], -csep[1]], [-csep[0], csep[1]], [csep[0], csep[1]]])\n</code></pre> <pre><code>e037 = clugen(2, 4, 1500, [1, 1], np.pi, [20, 20], 0, 0, 5, rng=rng(seed),\npoint_dist_fn=\"n\", clucenters_fn=centers_fixed)\ne038 = clugen(2, 4, 1500, [1, 1], np.pi, [20, 20], 0, 0, 5, rng=rng(seed),\npoint_dist_fn=\"n\", clucenters_fn=centers_fixed, clusizes_fn=clusizes_unif)\ne039 = clugen(2, 4, 1500, [1, 1], np.pi, [20, 20], 0, 0, 5, rng=rng(seed),\npoint_dist_fn=\"n\", clucenters_fn=centers_fixed, clusizes_fn=clusizes_equal)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne037, \"e037: normal dist. (default)\",\ne038, \"e038: unif. dist. (custom)\",\ne039, \"e039: equal size (custom)\")\n</code></pre>"},{"location":"generated/gallery/plot_2_2d_examples/#direct-specification-of-optional-parameters","title":"Direct specification of optional parameters","text":"<pre><code>seed = 123\n</code></pre> <pre><code>e040 = clugen(2, 4, 1000, [-1, 1], 0, [0, 0], 0, 0, 0.2, rng=rng(seed),\nproj_dist_fn=\"unif\", point_dist_fn=\"n\", clusizes_fn=[50, 200, 500, 2000],\nllengths_fn=[0, 2, 4, 6], clucenters_fn=[[-5, -5], [-2.5, -2.5], [0, 0], [2.5, 2.5]])\ne041 = clugen(2, 5, 1000, [[1, 1], [1, 0], [1, 0], [0, 1], [0, 1]],\n0, [0, 0], 0, 0, 0.2, rng=rng(seed),\nproj_dist_fn=\"unif\", point_dist_fn=\"n\",\nclusizes_fn=[200, 500, 500, 500, 500], llengths_fn=[0, 5, 5, 5, 5],\nclucenters_fn=[[0, 0], [0, 5], [0, -5], [5, 0], [-5, 0]])\ne042 = clugen(2, 5, 1000, [[0, 1], [0.25, 0.75], [0.5, 0.5], [0.75, 0.25], [1, 0]],\n0, [0, 0], 5, 0, 0.2, rng=rng(seed),\nproj_dist_fn=\"unif\", point_dist_fn=\"n\", clusizes_fn=[500, 500, 500, 500, 500],\nclucenters_fn=[[-5, 0], [-3, -0.3], [-1, -0.8], [1, -1.6], [3, -2.5]])\n</code></pre> <pre><code>plt = plot_examples_2d(\ne040, \"e040: direct params 1\",\ne041, \"e041: direct params 2\",\ne042, \"e042: direct params 3\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  10.999 seconds)</p> <p> Download Python source code: plot_2_2d_examples.py</p> <p> Download Jupyter notebook: plot_2_2d_examples.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_3_3d_examples/","title":"Examples in 3D","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_3_3d_examples/#examples-in-3d","title":"Examples in 3D","text":"<p>This section contains several examples on how to generate 3D data with pyclugen. To run the examples we first need to import the <code>clugen()</code> function:</p> <pre><code>from pyclugen import clugen\n</code></pre> <p>To make the examples exactly reproducible we'll import a random number generator from NumPy and pass it as a parameter to <code>clugen()</code>. We'll also create a small helper function for providing us a brand new seeded generator:</p> <pre><code>import numpy as np\nfrom numpy.random import PCG64, Generator\ndef rng(seed):\nreturn Generator(PCG64(seed))\n</code></pre> <p>To plot these examples we use the <code>plot_examples_3d</code> function:</p> <pre><code>from plot_functions import plot_examples_3d\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#manipulating-the-direction-of-cluster-supporting-lines","title":"Manipulating the direction of cluster-supporting lines","text":""},{"location":"generated/gallery/plot_3_3d_examples/#using-the-direction-parameter","title":"Using the <code>direction</code> parameter","text":"<pre><code>seed = 321\n</code></pre> <pre><code>e043 = clugen(3, 4, 500, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed))\ne044 = clugen(3, 4, 500, [1, 1, 1], 0, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed))\ne045 = clugen(3, 4, 500, [0, 0, 1], 0, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed))\n</code></pre> <pre><code>plt = plot_examples_3d(\ne043, \"e043: direction = [1, 0, 0]\",\ne044, \"e044: direction = [1, 1, 1]\",\ne045, \"e045: direction = [0, 0, 1]\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#changing-the-angle_disp-parameter-and-using-a-custom-angle_deltas_fn-function","title":"Changing the <code>angle_disp</code> parameter and using a custom <code>angle_deltas_fn</code> function","text":"<pre><code>seed = 321\n# Custom angle_deltas function: arbitrarily rotate some clusters by 90 degrees\ndef angdel_90_fn(nclu, astd, rng):\nreturn rng.choice([0, np.pi / 2], size=nclu)\n</code></pre> <pre><code>e046 = clugen(3, 6, 1000, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed))\ne047 = clugen(3, 6, 1000, [1, 0, 0], np.pi / 8, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed))\ne048 = clugen(3, 6, 1000, [1, 0, 0], 0, [10, 10, 10], 15, 1.5, 0.5, rng=rng(seed),\nangle_deltas_fn=angdel_90_fn)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne046, \"e046: angle_disp = 0\",\ne047, \"e047: angle_disp = \u03c0 / 8\",\ne048, \"e048: custom angle_deltas function\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#specifying-a-main-direction-for-each-cluster-and-changing-angle_disp","title":"Specifying a main <code>direction</code> for each cluster and changing <code>angle_disp</code>","text":"<pre><code>seed = 123\n# Define a main direction for each cluster\ndirs = [[1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 0], [-1, 1, 1]]\n</code></pre> <pre><code>e049 = clugen(3, 5, 1000, dirs, 0, np.zeros(3), 20, 0, 0.2, proj_dist_fn=\"unif\", rng=rng(seed))\ne050 = clugen(3, 5, 1000, dirs, np.pi / 12, np.zeros(3), 20, 0, 0.2, proj_dist_fn=\"unif\", rng=rng(seed))\ne051 = clugen(3, 5, 1000, dirs, np.pi / 4, np.zeros(3), 20, 0, 0.2, proj_dist_fn=\"unif\", rng=rng(seed))\n</code></pre> <pre><code>plot_examples_3d(\ne049, \"e049: angle_disp = 0\",\ne050, \"e050: angle_disp = \u03c0 / 12\",\ne051, \"e051: angle_disp = \u03c0 / 4\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#manipulating-the-length-of-cluster-supporting-lines","title":"Manipulating the length of cluster-supporting lines","text":""},{"location":"generated/gallery/plot_3_3d_examples/#using-the-llength-parameter","title":"Using the <code>llength</code> parameter","text":"<pre><code>seed = 789\n</code></pre> <pre><code>e052 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 0, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne053 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 10, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne054 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 30, 0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\n</code></pre> <pre><code>plt = plot_examples_3d(\ne052, \"e052: llength = 0\",\ne053, \"e053: llength = 10\",\ne054, \"e054: llength = 30\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#changing-the-llength_disp-parameter-and-using-a-custom-llengths_fn-function","title":"Changing the <code>llength_disp</code> parameter and using a custom <code>llengths_fn</code> function","text":"<pre><code>seed = 765\n</code></pre> <pre><code># Custom llengths function: line lengths tend to grow for each new cluster\ndef llen_grow_fn(nclu, llen, llenstd, rng):\nreturn llen * np.arange(nclu) + rng.normal(scale=llenstd, size=nclu)\ne055 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 15,  0.0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne056 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 15, 10.0, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\")\ne057 = clugen(3, 5, 800, [1, 0, 0], np.pi / 10, [10, 10, 10], 10,  0.1, 0.5, rng=rng(seed),\npoint_dist_fn=\"n\", llengths_fn=llen_grow_fn)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne055, \"e055: llength_disp = 0.0\",\ne056, \"e056: llength_disp = 10.0\",\ne057, \"e057: custom llengths function\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#manipulating-relative-cluster-positions","title":"Manipulating relative cluster positions","text":""},{"location":"generated/gallery/plot_3_3d_examples/#using-the-cluster_sep-parameter","title":"Using the <code>cluster_sep</code> parameter","text":"<pre><code>seed = 765\n</code></pre> <pre><code>e058 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [30, 10, 10], 25, 4, 3, rng=rng(seed))\ne059 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [10, 30, 10], 25, 4, 3, rng=rng(seed))\ne060 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [10, 10, 30], 25, 4, 3, rng=rng(seed))\n</code></pre> <pre><code>plt = plot_examples_3d(\ne058, \"e058: cluster_sep = [30, 10, 10]\",\ne059, \"e059: cluster_sep = [10, 30, 10]\",\ne060, \"e060: cluster_sep = [10, 10, 30]\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#changing-the-cluster_offset-parameter-and-using-a-custom-clucenters_fn-function","title":"Changing the <code>cluster_offset</code> parameter and using a custom <code>clucenters_fn</code> function","text":"<pre><code># Custom clucenters function: places clusters in a diagonal\ndef centers_diag_fn(nclu, csep, coff, rng):\nreturn np.ones((nclu, len(csep))) * np.arange(1, nclu + 1)[:, None] * np.max(csep) + coff\ne061 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [10, 10, 10], 12, 3, 2.5, rng=rng(seed))\ne062 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [10, 10, 10], 12, 3, 2.5, rng=rng(seed),\ncluster_offset=[30, -30, 30])\ne063 = clugen(3, 8, 1000, [1, 1, 1], np.pi / 4, [10, 10, 10], 12, 3, 2.5, rng=rng(seed),\ncluster_offset=[-40, -40, -40], clucenters_fn=centers_diag_fn)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne061, \"e061: default\",\ne062, \"e062: cluster_offset=[30, -30, 30]\",\ne063, \"e063: custom clucenters function\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#lateral-dispersion-and-placement-of-point-projections-on-the-line","title":"Lateral dispersion and placement of point projections on the line","text":""},{"location":"generated/gallery/plot_3_3d_examples/#normal-projection-placement-default-proj_dist_fnnorm","title":"Normal projection placement (default): <code>proj_dist_fn=\"norm\"</code>","text":"<pre><code>seed = 246\n</code></pre> <pre><code>e064 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 0.0, rng=rng(seed))\ne065 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 1.0, rng=rng(seed))\ne066 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 3.0, rng=rng(seed))\n</code></pre> <pre><code>plt = plot_examples_3d(\ne064, \"e064: lateral_disp = 0\",\ne065, \"e065: lateral_disp = 1\",\ne066, \"e066: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#uniform-projection-placement-proj_dist_fnunif","title":"Uniform projection placement: <code>proj_dist_fn=\"unif\"</code>","text":"<pre><code>seed = 246\n</code></pre> <pre><code>e067 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 0.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne068 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 1.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne069 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 3.0, rng=rng(seed),\nproj_dist_fn=\"unif\")\n</code></pre> <pre><code>plt = plot_examples_3d(\ne067, \"e067: lateral_disp = 0\",\ne068, \"e068: lateral_disp = 1\",\ne069, \"e069: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#custom-projection-placement-using-the-laplace-distribution","title":"Custom projection placement using the Laplace distribution","text":"<pre><code>seed = 246\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e070 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 0.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\ne071 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 1.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\ne072 = clugen(3, 4, 1000, [1, 0, 0], np.pi / 2, [20, 20, 20], 13, 2, 3.0, rng=rng(seed),\nproj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne070, \"e070: lateral_disp = 0\",\ne071, \"e071: lateral_disp = 1\",\ne072, \"e072: lateral_disp = 3\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#controlling-final-point-positions-from-their-projections-on-the-cluster-supporting-line","title":"Controlling final point positions from their projections on the cluster-supporting line","text":""},{"location":"generated/gallery/plot_3_3d_examples/#points-on-hyperplane-orthogonal-to-cluster-supporting-line-default-point_dist_fnn-1","title":"Points on hyperplane orthogonal to cluster-supporting line (default): <code>point_dist_fn=\"n-1\"</code>","text":"<pre><code>seed = 840\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e073 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed))\ne074 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\nproj_dist_fn=\"unif\")\ne075 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\nproj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne073, \"e073: proj_dist_fn=\\\"norm\\\" (default)\",\ne074, \"e074: proj_dist_fn=\\\"unif\\\"\",\ne075, \"e075: custom proj_dist_fn (Laplace)\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#points-around-projection-on-cluster-supporting-line-point_dist_fnn","title":"Points around projection on cluster-supporting line: <code>point_dist_fn=\"n\"</code>","text":"<pre><code>seed = 840\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\ne076 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=\"n\")\ne077 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=\"n\", proj_dist_fn=\"unif\")\ne078 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=\"n\", proj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne076, \"e076: proj_dist_fn=\\\"norm\\\" (default)\",\ne077, \"e077: proj_dist_fn=\\\"unif\\\"\",\ne078, \"e078: custom proj_dist_fn (Laplace)\")\n</code></pre>"},{"location":"generated/gallery/plot_3_3d_examples/#custom-point-placement-using-the-exponential-distribution","title":"Custom point placement using the exponential distribution","text":"<p>For this example we require the <code>clupoints_n_1_template()</code> helper function:</p> <pre><code>from pyclugen import clupoints_n_1_template\n</code></pre> <pre><code>seed = 840\n</code></pre> <pre><code># Custom point_dist_fn: final points placed using the Exponential distribution\ndef clupoints_n_1_exp(projs, lat_std, len, clu_dir, clu_ctr, rng):\ndef dist_exp(npts, lstd, rg):\nreturn lstd * rg.exponential(scale=2 / lstd, size=npts)\nreturn clupoints_n_1_template(projs, lat_std, clu_dir, dist_exp, rng=rng)\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Laplace distribution\ndef proj_laplace(len, n, rng):\nreturn rng.laplace(scale=len / 6, size=n)\n</code></pre> <pre><code>e079 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp)\ne080 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp, proj_dist_fn=\"unif\")\ne081 = clugen(3, 5, 1500, [1, 0, 0], np.pi / 3, [20, 20, 20], 22, 3, 2, rng=rng(seed),\npoint_dist_fn=clupoints_n_1_exp, proj_dist_fn=proj_laplace)\n</code></pre> <pre><code>plt = plot_examples_3d(\ne079, \"e079: proj_dist_fn=\\\"norm\\\" (default)\",\ne080, \"e080: proj_dist_fn=\\\"unif\\\"\",\ne081, \"e081: custom proj_dist_fn (Laplace)\")\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_3_3d_examples/#manipulating-cluster-sizes","title":"Manipulating cluster sizes","text":"<pre><code>seed = 555\n</code></pre> <pre><code># Custom clusizes_fn (e083): cluster sizes determined via the uniform distribution,\n# no correction for total points\ndef clusizes_unif(nclu, npts, ae, rng):\nreturn rng.integers(low=1, high=2 * npts / nclu + 1, size=nclu)\n</code></pre> <pre><code># Custom clusizes_fn (e084): clusters all have the same size, no correction for total points\ndef clusizes_equal(nclu, npts, ae, rng):\nreturn (npts // nclu) * np.ones(nclu, dtype=int)\n</code></pre> <pre><code># Custom clucenters_fn (all): yields fixed positions for the clusters\ndef centers_fixed(nclu, csep, coff, rng):\nreturn np.array([\n[-csep[0], -csep[1], -csep[2]],\n[csep[0], -csep[1], -csep[2]],\n[-csep[0], csep[1], csep[2]],\n[csep[0], csep[1], csep[2]]])\n</code></pre> <pre><code>e082 = clugen(3, 4, 1500, [1, 1, 1], np.pi, [20, 20, 20], 0, 0, 5, rng=rng(seed),\nclucenters_fn=centers_fixed, point_dist_fn=\"n\")\ne083 = clugen(3, 4, 1500, [1, 1, 1], np.pi, [20, 20, 20], 0, 0, 5, rng=rng(seed),\nclucenters_fn=centers_fixed, clusizes_fn=clusizes_unif, point_dist_fn=\"n\")\ne084 = clugen(3, 4, 1500, [1, 1, 1], np.pi, [20, 20, 20], 0, 0, 5, rng=rng(seed),\nclucenters_fn=centers_fixed, clusizes_fn=clusizes_equal, point_dist_fn=\"n\")\n</code></pre> <pre><code>plt = plot_examples_3d(\ne082, \"e082: normal dist. (default)\",\ne083, \"e083: unif. dist. (custom)\",\ne084, \"e084: equal size (custom)\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  5.484 seconds)</p> <p> Download Python source code: plot_3_3d_examples.py</p> <p> Download Jupyter notebook: plot_3_3d_examples.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_4_nd_examples/","title":"Examples in nD","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_4_nd_examples/#examples-in-nd","title":"Examples in nD","text":"<p>This section contains several examples on how to generate nD (n &gt; 3) data with pyclugen. To run the examples we first need to import the <code>clugen()</code> function:</p> <pre><code>from pyclugen import clugen\n</code></pre> <p>To make the examples exactly reproducible we'll import a random number generator from NumPy and pass it as a parameter to <code>clugen()</code>. We'll also create a small helper function for providing us a brand new seeded generator:</p> <pre><code>import numpy as np\nfrom numpy.random import PCG64, Generator\ndef rng(seed):\nreturn Generator(PCG64(seed))\n</code></pre> <p>To plot these examples we use the <code>plot_examples_nd</code> function:</p> <pre><code>from plot_functions import plot_examples_nd\n</code></pre>"},{"location":"generated/gallery/plot_4_nd_examples/#5d-example-with-default-optional-arguments","title":"5D example with default optional arguments","text":"<pre><code>seed = 123\n</code></pre> <pre><code># Number of dimensions\nnd = 5\n</code></pre> <pre><code>e085 = clugen(nd, 6, 1500, [1, 1, 0.5, 0, 0], np.pi / 16, 30 * np.ones(nd), 30, 4, 3, rng=rng(seed))\n</code></pre> <pre><code>plot_examples_nd(e085, \"e085: 5D with optional parameters set to defaults\")\n</code></pre>"},{"location":"generated/gallery/plot_4_nd_examples/#5d-example-with-proj_dist_fn-unif-and-point_dist_fn-n","title":"5D example with <code>proj_dist_fn = \"unif\"</code> and <code>point_dist_fn = \"n\"</code>","text":"<pre><code>seed = 579\n</code></pre> <pre><code># Number of dimensions\nnd = 5\n</code></pre> <pre><code>e086 = clugen(nd, 6, 1500, [0.1, 0.3, 0.5, 0.3, 0.1], np.pi / 12, 30 * np.ones(nd), 35, 5, 3.5,\nproj_dist_fn=\"unif\", point_dist_fn=\"n\", rng=rng(seed))\n</code></pre> <pre><code>plot_examples_nd(e086, \"e086: 5D with proj_dist_fn=\\\"unif\\\" and point_dist_fn=\\\"n\\\"\")\n</code></pre>"},{"location":"generated/gallery/plot_4_nd_examples/#4d-example-with-custom-projection-placement-using-the-beta-distribution","title":"4D example with custom projection placement using the Beta distribution","text":"<pre><code>seed = 963\n</code></pre> <pre><code># Number of dimensions\nnd = 4\n</code></pre> <pre><code># Custom proj_dist_fn: point projections placed using the Beta distribution\ndef proj_beta(len, n, rng):\nreturn len * rng.beta(0.1, 0.1, size=n) - len / 2\n</code></pre> <pre><code>e087 = clugen(nd, 5, 1500, np.ones(nd), np.pi / 6, 30 * np.ones(nd), 60, 15, 6, rng=rng(seed),\nproj_dist_fn=proj_beta)\n</code></pre> <pre><code>plot_examples_nd(e087, \"e087: 4D with custom proj_dist_fn (Beta)\")\n</code></pre> <p>Total running time of the script: ( 0 minutes  8.496 seconds)</p> <p> Download Python source code: plot_4_nd_examples.py</p> <p> Download Jupyter notebook: plot_4_nd_examples.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_5_mrg_examples/","title":"Merging and hierarchical cluster examples","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_5_mrg_examples/#merging-and-hierarchical-cluster-examples","title":"Merging and hierarchical cluster examples","text":"<p>This section contains several examples on how to merge cluster data, either generated with pyclugen or from other sources. To run the examples we first need to import the <code>clugen()</code> and <code>clugen()</code> functions:</p> <pre><code>from pyclugen import clugen, clumerge\n</code></pre> <p>To make the examples exactly reproducible we'll import a random number generator from NumPy and pass it as a parameter to <code>clugen()</code>. We'll also create a small helper function for providing us a brand new seeded generator:</p> <pre><code>import numpy as np\nfrom numpy.random import PCG64, Generator\ndef rng(seed):\nreturn Generator(PCG64(seed))\n</code></pre> <p>Although it is possible to merge data in any dimension, these examples will focus on merging 2D data. Therefore, we'll use the same <code>plot_examples_2d</code> function used for the 2D examples:</p> <pre><code>from plot_functions import plot_examples_2d\n</code></pre>"},{"location":"generated/gallery/plot_5_mrg_examples/#merging-two-data-sets-generated-with-clugen","title":"Merging two data sets generated with <code>clugen()</code>","text":"<pre><code>seed1 = 444\nseed2 = 555\n</code></pre> <pre><code>e088 = clugen(2, 5, 1000, [1, 1], np.pi / 12, [20, 20], 14, 1.2, 1.5, rng=rng(seed1),\nproj_dist_fn=\"unif\", point_dist_fn=\"n\")\ne089 = clugen(2, 3, 1500, [1, 0], 0.05, [20, 20], 0, 0, 4, rng=rng(seed2),\npoint_dist_fn=\"n\", cluster_offset = [20, 0])\ne090 = clumerge(e088, e089)\n</code></pre> <pre><code>plot_examples_2d(\ne088, \"e088: data set 1\",\ne089, \"e089: data set 2\",\ne090, \"e090: merged data sets\")\n</code></pre> <p>In the previous example, clusters from individual data sets remain as separate clusters in the merged data set. It's also possible to mantain the original cluster labels by setting the <code>clusters_field</code> parameter to <code>None</code>:</p> <pre><code>e091 = clumerge(e088, e089, clusters_field=None)\n</code></pre> <pre><code>plot_examples_2d(\ne088, \"e088: data set 1\",\ne089, \"e089: data set 2\",\ne091, \"e091: merged data sets\")\n</code></pre> <p></p>"},{"location":"generated/gallery/plot_5_mrg_examples/#adding-noise-to-a-clugen-generated-data-set","title":"Adding noise to a <code>clugen()</code>-generated data set","text":"<pre><code>seed = 333\n</code></pre> <pre><code>prng = rng(seed)\ne092 = {\"points\": 120 * prng.random((500, 2)) - 60, \"clusters\": np.ones(500, dtype=np.int32)}\ne093 = clumerge(e092, e090) # clumerge(e092, e088, e089) would also work\n</code></pre> <pre><code>plot_examples_2d(\ne090, \"e090: original merged data sets\",\ne092, \"e092: random uniform noise\",\ne093, \"e093: data sets with noise\",\npmargin=0)\n</code></pre>"},{"location":"generated/gallery/plot_5_mrg_examples/#merging-with-data-not-generated-with-clugen","title":"Merging with data not generated with <code>clugen()</code>","text":"<p>Data generated with <code>clugen()</code> can be merged with other data sets, for example data created with one of scikit-learn's generators:</p> <pre><code>seed = 321\n</code></pre> <pre><code>from sklearn.datasets import make_moons\nX, y = make_moons(100, noise=0.05, random_state=seed)\ne094 = {\"points\": X, \"clusters\": y}\ne095 = clugen(2, 4, 200, [1, 1], np.pi / 12, [1, 1], 0.1, 0.01, 0.25, rng=rng(seed),\nproj_dist_fn = \"unif\", point_dist_fn = \"n\")\ne096 = clumerge(e094, e095)\n</code></pre> <pre><code>plt = plot_examples_2d(\ne094, \"e094: generated w/ make_moons()\",\ne095, \"e095: generated w/ clugen()\",\ne096, \"e096: merged data\")\n</code></pre> <p></p> <p>We can also hierarchize clusters from different sources:</p> <pre><code>e097 = {**e094, \"hclusters\": np.ones(100, dtype=np.int32)}\ne098 = {**e095._asdict(), \"hclusters\": 2 * np.ones(200, np.int32)}\ne099 = clumerge(e097, e098, clusters_field=\"hclusters\")\n</code></pre> <pre><code>plt = plot_examples_2d(\ne097, \"e097: generated w/ make_moons()\",\ne098, \"e098: generated w/ clugen()\",\ne099, \"e099: merged data\",\nclusters_field=\"hclusters\")\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  3.471 seconds)</p> <p> Download Python source code: plot_5_mrg_examples.py</p> <p> Download Jupyter notebook: plot_5_mrg_examples.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_functions/","title":"Plot functions","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_functions/#plot-functions","title":"Plot functions","text":"<p>Several auxiliary functions for plotting the examples in this documentation.</p>"},{"location":"generated/gallery/plot_functions/#import-the-required-libraries","title":"Import the required libraries","text":"<pre><code>import matplotlib.pyplot as plt  # type: ignore\nimport numpy as np\nimport numpy.typing as npt\nimport pandas as pd\nimport seaborn as sns  # type: ignore\nfrom pyclugen import Clusters\n</code></pre>"},{"location":"generated/gallery/plot_functions/#clusters2df","title":"clusters2df","text":"<pre><code>def clusters2df(\n*exs: Clusters | dict[str, npt.ArrayLike], clusters_field: str = \"clusters\"\n) -&gt; pd.DataFrame:\n\"\"\"Convert a sequence of clusters to a Pandas dataframe.\"\"\"\ndfs = []\niex = 1\nfor ex in exs:\nif isinstance(ex, dict):\npoints = ex[\"points\"]\nclusters = ex[clusters_field]\nelse:\npoints = ex.points\nclusters = ex.clusters\ndf = pd.DataFrame(\ndata=points, columns=[f\"x{i}\" for i in range(np.size(points, 1))]\n)\ndf[\"cluster\"] = clusters.tolist()\ndf[\"example\"] = [iex] * clusters.size\ndfs.append(df)\niex += 1\nreturn pd.concat(dfs, ignore_index=True)\n</code></pre>"},{"location":"generated/gallery/plot_functions/#get_plot_lims","title":"get_plot_lims","text":"<pre><code>def get_plot_lims(df: pd.DataFrame, pmargin: float = 0.1):\n\"\"\"Determine the plot limits for the cluster data given in `df`.\"\"\"\n# Get maximum and minimum points in each dimension\nxmaxs = df.iloc[:, :-2].max()\nxmins = df.iloc[:, :-2].min()\n# Determine plot centers in each dimension\nxcenters = (xmaxs + xmins) / 2\n# Determine plots span for all dimensions\nsidespan = (1 + pmargin) * np.max(np.abs(xmaxs - xmins)) / 2\n# Determine final plots limits\nxmaxs = xcenters + sidespan\nxmins = xcenters - sidespan\nreturn xmaxs, xmins\n</code></pre>"},{"location":"generated/gallery/plot_functions/#plot_examples_1d","title":"plot_examples_1d","text":"<pre><code>def plot_examples_1d(*ets, ncols: int = 3, clusters_field: str = \"clusters\"):\n\"\"\"Plot the 1D examples given in the ets parameter.\"\"\"\n# Get examples\nex = ets[0::2]\n# Get titles\net = ets[1::2]\ndf = clusters2df(*ex, clusters_field=clusters_field)\n# Set seaborn's dark grid style\nsns.set_theme(style=\"darkgrid\")\n# Use seaborn to create the plots\ng = sns.FacetGrid(df, col=\"example\", hue=\"cluster\", col_wrap=ncols)\n# Plot the kernel density estimation plots\ng.map(sns.kdeplot, \"x0\", multiple=\"layer\", fill=True)\n# Get a flattened view of the axes array\ng_axes = g.axes.reshape(-1)\n# Determine the height of the rugs in the rug plot to 5% of total height\nrug_height = g_axes[0].get_ylim()[1] * 0.05\n# Plot the rug markers below the kde plots\ng.map(sns.rugplot, \"x0\", height=rug_height)\n# Set titles\nfor ax, t in zip(g_axes, et):\nax.set_title(t)\n</code></pre>"},{"location":"generated/gallery/plot_functions/#plot_examples_2d","title":"plot_examples_2d","text":"<pre><code>def plot_examples_2d(\n*ets, pmargin: float = 0.1, ncols: int = 3, clusters_field: str = \"clusters\"\n):\n\"\"\"Plot the 2D examples given in the ets parameter.\"\"\"\n# Get examples\nex = ets[0::2]\n# Get titles\net = ets[1::2]\ndf = clusters2df(*ex, clusters_field=clusters_field)\n# Get limits in each dimension\nxmaxs, xmins = get_plot_lims(df, pmargin=pmargin)\n# Set seaborn's dark grid style\nsns.set_theme(style=\"darkgrid\")\n# Use seaborn to create the plots\ng = sns.FacetGrid(\ndf,\ncol=\"example\",\nhue=\"cluster\",\nxlim=(xmins[0], xmaxs[0]),\nylim=(xmins[1], xmaxs[1]),\naspect=1,\ncol_wrap=ncols,\n)\ng.map(sns.scatterplot, \"x0\", \"x1\", s=10)\n# Set the plot titles and x, y labels\nfor ax, t in zip(g.axes, et):\nax.set_title(t)\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\n</code></pre>"},{"location":"generated/gallery/plot_functions/#plot_examples_3d","title":"plot_examples_3d","text":"<pre><code>def plot_examples_3d(\n*ets,\npmargin: float = 0.1,\nncols: int = 3,\nside=350,\nclusters_field: str = \"clusters\",\n):\n\"\"\"Plot the 3D examples given in the ets parameter.\"\"\"\n# Get examples\nex = ets[0::2]\n# Get titles\net = ets[1::2]\n# Number of plots and number of rows in combined plot\nnum_plots = len(ex)\nnrows = max(1, int(np.ceil(num_plots / ncols)))\nblank_plots = nrows * ncols - num_plots\ndf = clusters2df(*ex, clusters_field=clusters_field)\n# Get limits in each dimension\nxmaxs, xmins = get_plot_lims(df, pmargin=pmargin)\n# Reset to default Matplotlib style, to avoid seaborn interference\nsns.reset_orig()\n# To convert inches to pixels afterwards\npx = 1 / plt.rcParams[\"figure.dpi\"]  # pixel in inches\n# Use Matplotlib to create the plots\n_, axs = plt.subplots(\nnrows,\nncols,\nfigsize=(side * px * ncols, side * px * nrows),\nsubplot_kw=dict(projection=\"3d\"),\n)\naxs = axs.reshape(-1)\nfor ax, e, t in zip(axs, ex, et):\nax.set_title(t, fontsize=10)\nax.set_xlim(xmins[0], xmaxs[0])\nax.set_ylim(xmins[1], xmaxs[1])\nax.set_zlim(xmins[2], xmaxs[2])\nax.set_xlabel(\"$x$\", labelpad=-2)\nax.set_ylabel(\"$y$\", labelpad=-2)\nax.set_zlabel(\"$z$\", labelpad=-2)\nax.tick_params(labelsize=8, pad=-2)\nax.scatter(\ne.points[:, 0],\ne.points[:, 1],\ne.points[:, 2],\nc=e.clusters,\ndepthshade=False,\nedgecolor=\"black\",\nlinewidths=0.2,\n)\n# Remaining plots are left blank\nfor ax in axs[len(ex) : len(ex) + blank_plots]:\nax.set_axis_off()\nax.set_facecolor(color=\"white\")\nax.patch.set_alpha(0)\n</code></pre>"},{"location":"generated/gallery/plot_functions/#plot_examples_nd","title":"plot_examples_nd","text":"<pre><code>def plot_examples_nd(\nex: Clusters, t: str, pmargin: float = 0.1, clusters_field: str = \"clusters\"\n):\n\"\"\"Plot the nD example given in the ex parameter.\"\"\"\n# How many dimensions?\nnd = ex.points.shape[1]\ndf = clusters2df(ex, clusters_field=clusters_field)\n# Get limits in each dimension\nxmaxs, xmins = get_plot_lims(df, pmargin=pmargin)\n# Set seaborn's dark grid style\nsns.set_theme(style=\"darkgrid\")\n# Create pairwise plots with nothing on the diagonal\ng = sns.PairGrid(df.iloc[:, :-1], hue=\"cluster\", palette=\"deep\")\ng.map_offdiag(sns.scatterplot, s=10)\ng.figure.suptitle(t, y=1)\n# Decorate plot\nfor i in range(nd):\nfor j in range(nd):\nif i == j:\n# Set the x labels in the diagonal plots\nxycoord = (xmaxs[i] + xmins[i]) / 2\ng.axes[i, i].text(\nxycoord, xycoord, f\"$x{i}$\", fontsize=20, ha=\"center\", va=\"center\"\n)\nelse:\n# Set appropriate plot intervals and aspect ratio\ng.axes[i, j].set_xlim([xmins[j], xmaxs[j]])\ng.axes[i, j].set_ylim([xmins[i], xmaxs[i]])\ng.axes[i, j].set_aspect(1)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.006 seconds)</p> <p> Download Python source code: plot_functions.py</p> <p> Download Jupyter notebook: plot_functions.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"}]}